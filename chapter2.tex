\chapter{Background}
\label{cha:background}
Lorem ipsum dolor sit amet, consectetur adipiscing elit. Donec sed nunc orci. Aliquam nec nisl vitae sapien pulvinar dictum quis non urna. Suspendisse at dui a erat aliquam vestibulum. Quisque ultrices pellentesque pellentesque. Pellentesque egestas quam sed blandit tempus. Sed congue nec risus posuere euismod. Maecenas ut lacus id mauris sagittis egestas a eu dui. Class aptent taciti sociosqu ad litora torquent per conubia nostra, per inceptos himenaeos. Pellentesque at ultrices tellus. Ut eu purus eget sem iaculis ultricies sed non lorem. Curabitur gravida dui eget ex vestibulum venenatis. Phasellus gravida tellus velit, non eleifend justo lobortis eget. 

\section{The Coq Proof Assistant}
The implementation of the core of our register allocator will be performed in Coq. Coq is an interactive proof assistant that leverages a strongly typed functional programming language called Gallina for its computational part. 
During the course of the project will in fact focus more on the computational aspect of the implementation rather than proving the correctness of said algorithms.

\subsection{Function termination}
One feature of Coq that we will make extensive use of is the termination checking for functions. Using the \textbf{Fixpoint} keywork lets us insert a recursive function definition that pattern matches over inductive types.
During the evaluation of said definition Coq checks for the existence of a decreasing argument (between the arguments of the function) and does that for every branch of the match expression. If the previous condition is satisfied then this means that at some point we will reach the non-recursive constructor of the inductive type and so terminate our function will terminate.
Intuitively there exist more complicated functions that do not leverage this mechanism meaning that Coq will not be able to prove their termination easily, to solve this problem we can proceed in two different ways:
the first one is the easiest, it consists in forcing into the function signature a decreasing argument that the compiler can check, the argument is usually something like \textbf{(fuel : nat)} and the idea is that the algorithm iterates until \textbf{fuel} reaches zero. The problem with this solution is that we must know beforehand how many iterations we will need which is often a non-trivial task. If we fail to do so we could risk to terminate our function before the algorithm is actually completed ending up with an incorrect result.
The second way to ensure termination is to provide Coq with a proof of the termination of the algorithms

\section{Single Static Assigment}
\label{sec:ssa}
Single Static Assignment
Lorem ipsum dolor sit amet, consectetur adipiscing elit. Donec sed nunc orci. Aliquam nec nisl vitae sapien pulvinar dictum quis non urna. Suspendisse at dui a erat aliquam vestibulum. Quisque ultrices pellentesque pellentesque. Pellentesque egestas quam sed blandit tempus. Sed congue nec risus posuere euismod. Maecenas ut lacus id mauris sagittis egestas a eu dui. Class aptent taciti sociosqu ad litora torquent per conubia nostra, per inceptos himenaeos. Pellentesque at ultrices tellus. Ut eu purus eget sem iaculis ultricies sed non lorem. Curabitur gravida dui eget ex vestibulum venenatis. Phasellus gravida tellus velit, non eleifend justo lobortis eget.

\section{Register Allocation}
\label{sec:ra}
Register Allocation is

