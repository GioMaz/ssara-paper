% Errors

\chapter{Related Work}
\label{cha:relwork}

One first distinction we can make about RA approaches is between SSA-based RA and non-SSA-based RA. The former approach leverages the structural properties of \gls{ssa} programs in order to assign physical registers to virtual registers. In particular, we saw that \gls{ra} of \gls{ssa} programs, using graph coloring, can be solved both optimally and in polynomial time~\cite{HACK2006150}. However, due to its quadratic time complexity, this method is not suitable for compilers where time is a constraint. Namely, \gls{jit} compilers like the Java HotSpot\texttrademark{} client compiler~\cite{10.1145/1369396.1370017}. For this reason, many implementations use the linear scan algorithm (or one of its variants), initially presented by Poletto-Sarkar~\cite{10.1145/330249.330250}. Despite mainly benefitting graph coloring-based approaches, \gls{ssa} form proves also useful for linear scan algorithms. In fact, in the work presented by Wimmer-Franz~\cite{10.1145/1772954.1772979} they implement an improved version of the Java HotSpot\texttrademark{} client compiler where \gls{ssa} destruction is performed after \gls{ra}. Because of that, they are able to exploit \gls{ssa} properties in order to simplify \gls{ra} and \gls{ssa} destruction. Moreover, even LLVM uses `greedy'~\cite{Olesen2011Greedy} by default, which is an improved version of the linear scan algorithm.

Despite its wide usage, the linear scan approach produces suboptimal assignments. These result in a higher number of spills~\cite{10.1007/11688839_12} compared to graph coloring-based algorithms.

A second class of compilers, or specifically \gls{ra} algorithms, that we take into consideration, are the ones that are formally verified. Notable examples include CompCert~\cite{2006-Leroy-compcert} and CakeML~\cite{10.1145/2578855.2535841}. The former uses a graph coloring-based approach. However, the coloring algorithm of CompCert still produces suboptimal results~\cite{Rideau-Leroy-regalloc}. Additionally, its graph coloring algorithm is not verified itself. Instead, a validator for the result of the algorithm is verified, making \gls{ra} of CompCert sound, but not complete. On the other hand, CakeML employs an \gls{ra} algorithm that favors proof simplicity as opposed to the optimality of the result. In fact, it uses a deterministic algorithm much simpler than linear scan. Another related project is F$^\star$\cite{DBLP:journals/corr/BhargavanDFHPRR17}. Although not a verified compiler, it allows for extraction of code into OCaml, \FSharp, C, or WASM. Additionally, it is also possible to target assembly through the Vale toolchain~\cite{203642}, which allows for the formal verification of assembly programs. However, in that case, the user must embed the assembly directly in the source code, ultimately performing \gls{ra} themselves.


% Other RA algorithms (this however is optimal)
% Verified/unverified compilers examples (compcert, cakeml, f*)
% https://chatgpt.com/c/68ad5e29-5514-8326-9a0a-c33893c81d35