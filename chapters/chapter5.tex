% Errors

\chapter{Extraction}
\label{cha:extraction}

In this chapter, we put together the different components of our \gls{ra} pipeline. In \Cref{sec:pipeline}, we define the \texttt{regassign} function that does exactly that. In \Cref{sec:codegen}, we discuss the generation of \gls{nasm} code. Finally, in \Cref{sec:examples}, we present some examples of translated \gls{jair} programs.

\section{Composing the Pipeline}
\label{sec:pipeline}

After defining all the steps of our register assignment pipeline, we extract them into OCaml.
In particular, we extract the following functions:
\begin{itemize}
  \item \texttt{Vm.run} to interpret our programs;
  \item \texttt{LivenessInfo.analyze\_program} to obtain the liveness information of the program;
  \item \texttt{InterfGraph.get\_ig} to convert the liveness information into an interference graph;
  \item \texttt{Peo.eliminate} to obtain the \gls{peo};
  \item \texttt{Color.get\_coloring} to construct the coloring map;
  \item \texttt{Color.color\_program} to convert each virtual register of the program into its assigned physical register;
  \item \texttt{Destruct.ssa\_destruct} to translate the $\phi$-instructions;
\end{itemize}

After extraction, we compose the various phases of our \gls{ra} pipeline into the \texttt{regassign} function:

\begin{lstlisting}[style=OCaml]
let regassign irvreg_program =
  (* Perform liveness analysis *)
  let (programinfo, _) = analyze_program irvreg_program fuel_analyze in
  (* Build the interference graph *)
  let interfgraph = get_ig programinfo in
  (* Build the PEO *)
  let peo = eliminate interfgraph in
  (* Build the coloring *)
  let coloring =
    match get_coloring peo interfgraph with
    | Some c -> c
    | None -> failwith "Not enough registers to complete assignment"
  in
  (* Assign colors *)
  let irpreg_program = color_program coloring irvreg_program in
  (* Perform SSA destruction *)
  ssa_destruct fuel_destruct irpreg_program
;;
\end{lstlisting}

This function accepts a program written in \gls{jair} and returns an equivalent program without $\phi$-instructions and using only x86-64 registers.
Note that, at line 12, we throw an expection if we are not able to perform the coloring due to a high number of variables, this check is mandatory, as we do not perform spilling.

\section{Code Generation}
\label{sec:codegen}

After obtaining the converted data structure, the generation of assembly code is straightforward. We simply perform a depth-first visit on the \gls{cfg} and generate the assembly code for each basic block.
In our implementation, we chose to emit assembly with the \gls{nasm} syntax.

The following OCaml function does exactly so, writing the assembly code of a program into the specified output channel:

\begin{lstlisting}[style=OCaml]
let gen_irpreg_program out program =
  let visited = ref LblSet.empty in
  let rec gen_irpreg_program_aux out program =
    let IRPreg.Block (l, ps, is, j) = Lazy.force_val program in

    if not (LblSet.mem l !visited) then (
      visited := LblSet.add l !visited;

      if not (List.is_empty ps) then
        failwith
          "Malformed program, should not contain phi instructions";

      (* Generate label *)
      gen_label out l;

      (* Generate instructions *)
      gen_insts out is;

      (* Generate jump instruction *)
      match Lazy.force_val j with
      | IRPreg.CondJump (c, r, v, b1, b2) ->
        gen_condjump out c r v b1 b2;
        gen_irpreg_program_aux out b1;
        gen_irpreg_program_aux out b2;

      | IRPreg.Jump b ->
        gen_jump out b;
        gen_irpreg_program_aux out b;

      | IRPreg.Ret r ->
        gen_ret out r
    )
  in
  gen_section out ".text";
  gen_start out program;
  gen_irpreg_program_aux out program
;;
\end{lstlisting}

At line 14, we generate the label of the current block, using the \texttt{gen\_label} function. Then, at line 17 we do the same for the body of instructions of the basic block. Finally, at line 20, we generate the jump instruction. We continue with the recursion until we either reach a \texttt{Ret} instruction or we encounter an already visited block.

It is important to note that \gls{jair} is a three-address code representation, while \gls{nasm} only allows instructions that have a maximum of two arguments. Because of that, translation of binary operations must be treated specially.
Given physical registers \texttt A \texttt B, and \texttt C, we identify all the possible cases of a binary, non-commutative operation:
\begin{lstlisting}[style=Rocq]
Definition i1 : inst := r(A) <- r(A) / r(A).
Definition i2 : inst := r(A) <- r(A) / r(B).
Definition i3 : inst := r(A) <- r(B) / r(A).
Definition i4 : inst := r(A) <- r(B) / r(B).
Definition i5 : inst := r(A) <- r(B) / r(C).
\end{lstlisting}

% \begin{enumerate}
%   \item \label{itm:i1} \lstinline{Definition i1 : inst := r(A) <- r(A) / r(A).}
%   \item \label{itm:i2} \lstinline{Definition i2 : inst := r(A) <- r(A) / r(B).}
%   \item \label{itm:i3} \lstinline{Definition i3 : inst := r(A) <- r(B) / r(A).}
%   \item \label{itm:i4} \lstinline{Definition i4 : inst := r(A) <- r(B) / r(B).}
%   \item \label{itm:i5} \lstinline{Definition i5 : inst := r(A) <- r(B) / r(C).}
% \end{enumerate}

\lstset{style=NASM}
In instruction \texttt{i1}, a \gls{nasm} translation is straightforward. We can, in fact, use \lstinline{idiv A A}. The same goes for \texttt{i2}, where we can use \lstinline{idiv A B}. However, in \texttt{i3}, we see that no singular \gls{nasm} instruction can perform the intended operation. In particular, if we translate the operation as \lstinline{idiv A B}, we obtain an incorrect result, as division is non-commutative. Whereas, if we translate it as \lstinline{idiv B A}, the result will be written to register \texttt B, which is not the intended destination. For this case we use the following approach:

\begin{lstlisting}[style=NASM]
mov tmp A
mov A B
idiv A tmp
\end{lstlisting}

At line 1, we move the value of \texttt A into a temporary. At line 2, we move the content of \texttt B into the target register \texttt A. Finally, at line 3, we divide \texttt A (containing the initial value of \texttt B) by \texttt{tmp} (containing the initial value of \texttt A).
It is important to note that register \texttt{tmp} is only used inside \texttt{Point1} and \texttt{Point2} blocks. Because of that, there is no risk of colliding with a previous usage of that register.

Now, even \texttt{i4} requires multiple \gls{nasm} instructions, as a literal translation would still overwrite the content of \texttt B. We solve this issue with the following code sequence:

\begin{lstlisting}
mov A B
idiv A B
\end{lstlisting}

The same goes for \texttt{i5}, which can be translated into:

\begin{lstlisting}
mov A B
idiv A C
\end{lstlisting}

In the previous examples, we used the division operator, which is binary and non-commutative. This is arguably the hardest case we could encounter, as for unary operators and load/store instructions, translation to \gls{nasm} is straightforward.
We introduce a function specifically for handling the cases we just discussed:

\begin{lstlisting}[style=OCaml]
let gen_3ac_2ac out opcode r r' v =
  if r = r' then
    gen_bininst out opcode  (string_of_reg r) (string_of_val v)
  else
    match v with

    (* r(0) <- r(1) / i(100) *)
    | IRPreg.Imm x ->
      gen_bininst out MOV     (string_of_reg r) (string_of_reg r');
      gen_bininst out opcode  (string_of_reg r) (string_of_int x)

    (* r(0) <- r(1) / r(2) *)
    | IRPreg.Reg r'' ->
      if r = r'' then (
        gen_bininst out MOV     (string_of_reg tmp) (string_of_reg r');
        gen_bininst out opcode  (string_of_reg tmp) (string_of_reg r'');
        gen_bininst out MOV     (string_of_reg r)   (string_of_reg tmp)
      ) else (
        gen_bininst out MOV     (string_of_reg r) (string_of_reg r');
        gen_bininst out opcode  (string_of_reg r) (string_of_reg r'')
      )

    (* r(0) <- r(1) / p(100) *)
    | IRPreg.Ptr p ->
      gen_bininst out MOV     (string_of_reg r) (string_of_reg r');
      gen_bininst out opcode  (string_of_reg r) (string_of_int p)
;;
\end{lstlisting}

At line 2, we handle the cases where the destination register is the same as the first operand. This translates directly into a \gls{nasm} instruction. At line 8, we handle the case where the second operand is an immediate integer value. Here, we just need to move the first operand into the destination register, and then perform the operation. At line 14, we implement the cases we discussed previously. Expect for \texttt{i1} and \texttt{i2}, which are handled together with the other instructions at line 2. Finally, at line 24, we handle the case where the second operand is a pointer. Since pointers are also immediate values, we emit the same instructions as the first branch of the match.

\section{Examples}
\label{sec:examples}

Here we present some \gls{jair} programs and their compiled version. We also include their return values, respectively on the \gls{jair} interpreter, and on x86-64 hardware.
In \Cref{fig:ex1}, we translate a \gls{jair} program that computes the factorial of five. The \gls{ra} phase finds an optimal coloring with two registers, namely \texttt{rcx} and \texttt{rbx}. Additionally, at lines 18 and 19, we use \texttt{rax} and \texttt{rdi} to perform a syscall and terminate the program. After running the two programs, both of them return \texttt{120}.

% /-----------+
% | EXAMPLE 1 |
% +-----------/
\begin{figure}[ht]
\begin{minipage}{0.68\linewidth}
\centering
\begin{lstlisting}[style=Rocq]
Definition b3 : block :=
  Block (Normal 3) [] [] (ret r(5)).

CoFixpoint b2 : block :=
  Block (Normal 2) [
    (* Iterator *)
    r(2) <- phi [(0, Normal 1); (4, Normal 2)];
    (* Accumulator *)
    r(3) <- phi [(1, Normal 1); (5, Normal 2)]
  ] [
    r(4) <- r(2) - i(1);
    r(5) <- r(3) * r(4)
  ] (
    if r(4) <= i(1)
    then b3
    else b2
  ).

Definition b1 : block :=
  Block (Normal 1) [] [
    r(0) <- i(5);   (* Iterator *)
    r(1) <- r(0)    (* Accumulator *)
  ] (Jump b2).
\end{lstlisting}
\end{minipage}
\hfill
\begin{minipage}{0.28\linewidth}
\centering
\begin{lstlisting}[style=NASM]
section .text
global _start
_start:
  jmp L1
L1:
  mov rcx,  5
  mov rbx,  rcx
  jmp L2
L2:
  sub rcx,  1
  imul  rbx,  rcx
  cmp rcx,  1
  jle L2.1
  jmp L2.2
L2.1:
  jmp L3
L3:
  mov rax,  60
  mov rdi,  rbx
  syscall
L2.2:
  jmp L2
\end{lstlisting}
\end{minipage}
\caption{Left: \gls{jair} program that computes the factorial of five. Right: translation of the program into \gls{nasm}.}
\label{fig:ex1}
\end{figure}

In \Cref{fig:ex2}, we translate a simple program that increments a counter up to twenty, with a step of three. Here, the \gls{ra} returns a two-coloring with registers \texttt{rbx} and \texttt{rcx}. With the addition of \texttt{rax} and \texttt{rdi}, in order to perform the final syscall.

% /-----------+
% | EXAMPLE 2 |
% +-----------/
\begin{figure}[ht]
\begin{minipage}{0.68\linewidth}
\centering
\begin{lstlisting}[style=Rocq]
Definition b3 :=
  Block (Normal 3) [] []
    (ret r(3)).

CoFixpoint b2 :=
  Block (Normal 2) [
    r(2) <- phi [(0, Normal 1); (3, Normal 2)]
  ] [
    r(3) <- r(2) + i(3)
  ] (
    if r(3) < r(1)
    then b2
    else b3
  ).

Definition b1 :=
  Block (Normal 1) [] [
    r(0) <- i(0);
    r(1) <- i(20)
  ] (Jump b2).
\end{lstlisting}
\end{minipage}
\hfill
\begin{minipage}{0.28\linewidth}
\centering
\begin{lstlisting}[style=NASM]
section .text
global _start
_start:
  jmp  L1
L1:
  mov rbx,  0
  mov rcx,  20
  jmp L2
L2:
  add rbx,  3
  cmp rbx,  rcx
  jl  L2.1
  jmp L2.2
L2.1:
  jmp L2
L2.2:
  jmp L3
L3:
  mov rax,  60
  mov rdi,  rbx
  syscall
\end{lstlisting}
\end{minipage}
\caption{Left: \gls{jair} program that increments a counter with a step of three. Right: translation of the program into \gls{nasm}.}
\label{fig:ex2}
\end{figure}

In \Cref{fig:ex3}, we translate a program that computes the Twelfth Fibonacci number. Here, as we would expect, we obtain a three-coloring. With registers \texttt{rbx}, \texttt{rcx} and \texttt{rdx}. In the \gls{jair} program, we use the $\phi$-instruction at lines 6 and 7 in order to copy the `new' temporary variable \texttt{r(4)} into the `old' register \texttt{r(3)}. This translates into the parallel move that we see in the \gls{nasm} code under block \texttt{L2.2}, at line 27. After executing both of the programs, their result is \texttt{144}.

% /-----------+
% | EXAMPLE 3 |
% +-----------/
\begin{figure}[ht]
\begin{minipage}{0.68\linewidth}
\centering
\begin{lstlisting}[style=Rocq]
Definition b3 : block :=
  Block (Normal 3) [] [] (ret r(6)).

CoFixpoint b2 : block :=
  Block (Normal 2) [
    r(3) <-
      phi [(0, Normal 1); (4, Normal 2)];
    r(4) <-
      phi [(1, Normal 1); (6, Normal 2)];
    r(5) <-
      phi [(2, Normal 1); (7, Normal 2)]
  ] [
    r(6) <- r(4) + r(3);  (* New first temp *)
    r(7) <- r(5) - i(1)   (* New iterator *)
  ] (
    if r(7) = i(1)
    then b3
    else b2
  ).

Definition b1 : block :=
  Block (Normal 1) [] [
    r(0) <- i(0);  (* Second temp *)
    r(1) <- i(1);  (* First temp *)
    r(2) <- i(12)  (* Iterator*)
  ] (Jump b2).
\end{lstlisting}
\end{minipage}
\hfill
\begin{minipage}{0.28\linewidth}
\centering
\begin{lstlisting}[style=NASM]
section .text
global _start
_start:
  jmp L1
L1:
  mov rdx,  0
  mov rcx,  1
  mov rbx,  12
  mov rax,  rdx
  mov rdx,  rcx
  mov rcx,  rax
  jmp L2
L2:
  mov rax,  rdx
  add rax,  rcx
  mov rcx,  rax
  sub rbx,  1
  cmp rbx,  1
  je  L2.1
  jmp L2.2
L2.1:
  jmp L3
L3:
  mov rax,  60
  mov rdi,  rcx
  syscall
L2.2:
  mov rax,  rdx
  mov rdx,  rcx
  mov rcx,  rax
  jmp L2
\end{lstlisting}
\end{minipage}
\caption{Left: \gls{jair} program that computes the Twelfth Fibonacci number. Right: translation of the program into \gls{nasm}.}
\label{fig:ex3}
\end{figure}