% Errors

\chapter{Conclusion}
\label{cha:conclusion}

In this work, we laid the foundation for a verified implementation of \gls{ssa}-based \gls{ra} in Rocq. We introduced both the syntax and the semantics of \gls{jair}. Our initial intention was to rule out as many ill-formed \gls{ssa} programs as possible purely by syntax. In \Cref{sec:jair-syntax}, we discussed the choices we made in order to obtain this property. However, as explained in \Cref{subsec:limitations}, some inconsistencies were still possible. Along with that, we developed an interpreter for programs in \gls{jair}. Then, we implemented the \gls{ra} algorithm presented by Hack-Grund-Goos~\cite{HGG:2006:RA-SSA} in Rocq. After that, we extracted the whole \gls{ra} pipeline to OCaml and implemented a \gls{nasm} code generator for \gls{jair} programs.
Our verification effort focused on the core of the coloring algorithm. In particular, with \Cref{thm:term-elim}, we proved termination of the \texttt{eliminate} function. We also proved partial correctness of the step function \texttt{eliminate\_step} with \Cref{thm:par-cor}. As a followup, we could introduce additional mechanized proofs for \Cref{lem:chordal12}, \Cref{lem:chordal21}, and \Cref{thm:cho-inv}. In the future, we aim to verify other already existing parts of the \gls{ra}. Namely, the liveness analysis, defined in \Cref{sec:liveness}, the construction of the interference graph, defined in \Cref{subsec:ig}, and the reconstruction of the interference graph after elimination, defined in \Cref{subsec:coloring}. After that, we plan to introduce other verified steps, such as spilling and coalescing, in order to complete the register allocation pipeline. Finally, we seek to implement a parser for \gls{jair} programs, in order to enforce \gls{ssa} well-formedness through semantic analysis and allow for proper comparison with other \gls{ra} approaches via benchmarking.