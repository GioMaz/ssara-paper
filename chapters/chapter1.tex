% Errors

\chapter{Introduction}
\label{cha:intro}

Register allocation is the process of assigning each variable, or virtual register, used in a program to one of the limited physical registers available on the target hardware. While high-level programming languages allow developers to define an arbitrary number of variables to simplify software development, actual hardware architectures impose strict limits. For example, the x86 architecture provides only 16 general-purpose registers.

The main goal of register allocation is to map these virtual registers to physical ones in a way that preserves the original semantics of the program. A critical constraint is that variables which are simultaneously live, meaning they hold values needed later in the execution, must be assigned to distinct registers. Otherwise, one variable may overwrite the value of another, leading to incorrect program behavior.

In addition to satisfying correctness constraints, register allocation also involves solving several optimization problems. One such problem is reducing the number of variables that are stored on the stack, since accessing memory is considerably slower than accessing registers. Another optimization seeks to minimize the number of copy instructions inserted between registers, especially after branches, in order to reduce the total number of executed instructions and improve performance.

It is a well-known result that register allocation can be reduced to the problem of graph coloring, where each node represents a live range of a variable and edges represent conflicts between variables that cannot share the same register. This problem is computationally hard and typically requires heuristic methods in practice. However, for programs written in Static Single Assignment (SSA) form, register allocation becomes more tractable and can be solved using algorithms that run in polynomial time.

This work presents a complete implementation of a register allocator, with a focus on formal reasoning and partial verification of its core components. The structure of the implementation is as follows:

\begin{itemize}
\item In \Cref{sec:syntax}, we define an intermediate language that adheres closely to SSA principles while remaining suitable for register allocation;
\item In \Cref{sec:semantics}, we provide an operational semantics for this intermediate language by defining a virtual machine that can execute programs written in it;
\item In \Cref{sec:livenessinfo}, \Cref{sec:coloring}, and \Cref{sec:ssadestr}, we present the key steps of the allocation pipeline, including liveness analysis, graph coloring, and SSA destruction. We focus mainly on the graph coloring pass since it plays a central role in the register allocation process;
\item In \Cref{sec:coloring}, we discuss the verification of our implementation of the algorithm in Coq;
\item In \Cref{sec:extraction}, we discuss the extraction of the Coq code into OCaml code and compare the results of some example programs compiled to x86 assembly with the results of the same programs run on the previously defined virtual machine.
\end{itemize}

Starting from liveness analysis and ending with SSA destruction, this pipeline is developed using the Coq Proof Assistant, which allows us to verify the correctness of the core register allocation algorithm. Once verified, the code is extracted into an efficient language, OCaml, and compiled into a working binary.