% Errors

\chapter{\glsentrylong{ra}}
\label{cha:ra}

\section{Liveness Analysis}
\label{sec:liveness}

In this phase, we compute the set of live variables at each program point. This step is crucial for determining which variables interfere and, therefore constitute an edge of the interference graph.

Generally a liveness analysis algorithm works this way:
we start from the last instruction of the program and go back to the start instruction in a post-order fashion, while we do that we compute the following sets for each instruction:
\begin{itemize}
  \item \texttt{live\_in[i]} which contains the variables that are live \textit{before} the execution of instruction \texttt i;
  \item \texttt{live\_out[i]} which instead contains the variables live \textit{after} the execution of \texttt i;
  \item \texttt{def[i]} are the variables created by the instruction, in our language this set is either a singleton or the empty set as we can only define at most one variable per instruction;
  \item \texttt{use[i]} are the variables used as arguments by the instruction, at most two in our language since that is the maximum arity of our expressions;
\end{itemize}

Since in our language instructions can be of three different kinds we define different dataflow equations for each instruction type.

We start by defining the dataflow equations for the ALU-instructions:
\begin{align*}
  \texttt{live\_in[i]} &= \texttt{use[i]} \cup (\texttt{live\_out[i]} \setminus \texttt{def[i]}) \\
  \texttt{live\_out[i]} &= \bigcup \limits_{\texttt j \in \texttt{succ[i]}} \texttt{live\_in[j]}
\end{align*}

Since the computation is done backwards we start with the \texttt{live\_out[i]} set, which must contain the variables that are required by the successors of \texttt i. The
\texttt{live\_in[i]} set must instead contain the variables required by \texttt i, identified by \texttt{use[i]} and the variables that are required by the next instructions, identified by \texttt{live\_out[i]} $\setminus$ \texttt{def[i]}.
Here there are some things to note, first of all that the set $\texttt{live\_out[i\_n]} = \emptyset$ where \texttt{i\_n} is the last instruction of the program, since no variables are live after the program ends, we start from this assumption at the beginning of the procedure.

For jump instructions instead, the dataflow equations are similar, we just simplify the first dataflow equation by removing \texttt{def[i]} as jump instructions never define variables.

Now, because of the different semantics of $\phi$-instructions we must define their dataflow equations separately. In particular, we define the liveness information of the whole section instead of for single $\phi$-instructions, this is because, as was explained in \Cref{subsec:phi}, these instructions are executed parallelly.
We compute:
\begin{align*}
  \texttt{live\_in[ps]} &= \texttt{phi\_defs[ps]} \cup \texttt{live\_out[ps]} \\
  \texttt{live\_out[ps]} &= \bigcup \limits_{\texttt j \in \texttt{succ[ps]}} \texttt{live\_in[j]}
\end{align*}
where \texttt{phi\_defs[ps]} contains the left-hand sides of the $\phi$-instructions.

Starting again with \texttt{live\_out[ps]}, we define it as the union of the variables that are live before the first ALU-instruction of the block. \texttt{live\_in[ps]} is instead the set of variables that are defined in the $\phi$-instructions together with the variables that are required after the $\phi$-instructions, intuitively the variables in \texttt{phi\_defs[ps]} are already defined before reaching the start of the block since their execution happens during the jump.

\section{Register Assignment}
\label{sec:ra}

% As explained in \Cref{subsec:ssara} register assignment is considered equivalent to the task of graph coloring of the interference graph. Before starting with the coloring let's recall \Cref{def:ig}. A chordal graph is a graph for which there exists a \gls{peo}, that is, there exists a simplicial node such that, if we remove that node the graph is still chordal. The \gls{peo} is then the ordering in which those nodes are removed.

The approach we use to perform \gls{ra}~\cite{HGG:2006:RA-SSA} is the following:
\begin{itemize}
  \item We use the liveness information, obtained from the previous step, to build the interference graph;
  \item We iteratively remove the simplicial nodes from the interference graph obtaining a \gls{peo};
  \item We reinsert the nodes of the \gls{peo} in \textit{reverse} order into the interference graph. While doing that, we assign them a color that is not already taken by their neighborhoods;
\end{itemize}

\subsection{Building the Interference Graph}

After extracting the liveness information from our \gls{cfg}, we use it to build the interference graph.
The reasoning behind the creation of the interference graph is straightforward. We go through every live set computed in the previous step, and we insert it as a clique in the interference graph. This follows intuitively by the fact that, if two variables are live in the same instruction, then they interfere, as stated in \Cref{def:ig}.

The function used to populate the interference graph is the following:

\begin{lstlisting}[style=Rocq]
Definition get_ig (pi : ProgramInfo.dict) : InterfGraph.dict :=
  fold_left
    (fun g l =>
      match ProgramInfo.get pi l with
      | Some (BlockInfo iis) => ig_insert_instinfos g iis
      | None => g
      end)
    (ProgramInfo.keys pi)
    InterfGraph.empty.
\end{lstlisting}

At line 5, we use \texttt{ig\_insert\_instinfos}. This function, given an interference graph and a list of live sets, returns a graph where a clique is added for each live set of the list.

\subsection{Obtaining a \glsentrylong{peo}}
\label{subsec:peo}

Recalling \Cref{def:simplicial} we implement a function that determines whether a node of a graph is simplicial:

\begin{lstlisting}[style=Rocq]
Definition is_simplicialb (g : InterfGraph.dict) (r : reg) : bool :=
  let nbors := InterfGraph.get g r in
  regs_mem r (InterfGraph.keys g) &&
  is_cliqueb g nbors.
\end{lstlisting}

At line 2, we get the neighborhood of \texttt r using \texttt{InterfGraph.get}. At line 3, we check that \texttt r is actually part of the graph. Finally, at line 4, we check whether the neighborhood of \texttt r is a clique, using \texttt{is\_cliqueb}.
We now define a function that lets us find any simplicial node in a graph:

\begin{lstlisting}[style=Rocq]
Definition find_next (g : InterfGraph.dict) : option reg :=
  find (is_simplicialb g) (InterfGraph.keys g).
\end{lstlisting}

Here, we find the first node of the graph that respects the \texttt{(is\_simplicialb g)} condition. Note that the output node is an optional value, since the function may also receive a non-chordal graph which may not have a simplicial node. Because of that we need to propagate the option wrapper to all the return values of the subsequent functions.
As we will see in \Cref{cha:extraction}, upon receiving a \texttt{None} constructor we will to throw an exception, signaling to the user that the interference graph (and likely even the initial \gls{jair} program) is ill-formed.

Now we proceed with the step function for the \texttt{eliminate} function:

\begin{lstlisting}[style=Rocq]
Definition eliminate_step
  (g : InterfGraph.dict) : option (reg * InterfGraph.dict):=
  match find_next g with
  | Some next =>
    Some (next, ig_remove_node g next)
  | None => None
  end.
\end{lstlisting}

This function takes an interference graph which is chordal, finds a simplicial node, removes it, and returns both the removed node and the resulting graph.
Note that, because of \Cref{def:chordal}, if the input graph is chordal, then the function will never return the \texttt{None} constructor. Furthermore, the resulting graph will also be chordal.

Now we define the \texttt{eliminate} function, that is, the function for obtaining a \gls{peo}:

\begin{lstlisting}[style=Rocq]
Function eliminate
  (g : InterfGraph.dict) {measure InterfGraph.size g} : list reg :=
  match eliminate_step g with
  | Some (next, g') => next :: (eliminate g')
  | None => nil
  end.
\end{lstlisting}

The definition of the function is straightforward. We take an interference graph, and we remove the simplicial nodes until it becomes the empty graph. At each recursive call, we append the removed node at the end of the list.
As was mentioned in \Cref{subsec:funterm} Rocq has trouble automatically verifying the termination of this function, because of that we add an annotation that tells it that the decreasing property lies in the size of the interference graph. We will also prove this in \Cref{cha:verification}.

\subsection{Coloring}
\label{subsec:coloring}

The intuition behind the coloring algorithm is the following, first we make the following assumptions:

\begin{itemize}
  \item The interference graph $G$ obtained from the previous phase is chordal, which we know from \Cref{thm:chordal-chromatic};
  \item The chromatic number $\omega(G)$ is less than or equal to the number of available registers $k$, that is, we assume that spilling already happened, making the graph $k$-colorable;
\end{itemize}

Now take into consideration a single iteration of the algorithm mentioned at the beginning of \Cref{sec:ra}. The node we are about to color is simplicial, meaning that its neighborhood forms a clique. Even if not every element of the neighborhood is colored, the colored neighbors still form a clique (a subset of a clique is still a clique) meaning that the next step consists in finding a color that is not used by the colored neighbors, which is always possible since we assume that $\omega(G) \leq k$.

Given the intuition behind the algorithm, we start with the definition of the \texttt{Coloring} object as a dictionary from virtual registers to physical registers, this object will be the output of the coloring phase.

As we mentioned before, at each position of the \textit{reversed} \gls{peo} we find a node whose colored neighborhood forms a clique, because of that, in order to assign this node a new color we pick a random one from the complement of the neighborhood colors. We define a function specifically for this purpose.

\begin{lstlisting}[style=Rocq]
Definition preg_compl (colors : set preg) : option preg :=
  match IRPreg.regs_diff preg_allowed colors with
  | nil => None
  | c :: _ => Some c
  end.
\end{lstlisting}

Here, given a set of registers we calculate the difference with the set of registers \texttt{preg\_allowed}, and we extract an arbitrary element from it, note that the result of this function is optional since, if we run out of registers, we are not able to extract from the complement and ultimately perform register assignment. This, however, is an unexpected case solved by spilling.

Now we use the function we just defined to color a single node given its interference graph and the current coloring:

\begin{lstlisting}[style=Rocq]
Definition get_color
  (v : IRVreg.reg) (g : InterfGraph.dict) (c : Coloring.dict)
  : option IRPreg.reg :=
  let nbors := InterfGraph.get g v in
  let used := map (Coloring.get c) nbors in
  preg_compl used.
\end{lstlisting}

Finally, we introduce the function to obtain the complete coloring of the interference graph, the procedure is the same as explained at the beginning of \Cref{subsec:coloring}.

\begin{lstlisting}[style=Rocq]
Definition get_coloring (peo : list IRVreg.reg) (g : InterfGraph.dict)
  : option Coloring.dict :=
  let fix get_coloring_aux (peo : list IRVreg.reg) (c : Coloring.dict)
    : option Coloring.dict :=
    match peo with
    | nil => Some c
    | v :: peo =>
      match get_color v g c with
      | Some p =>
        let c := Coloring.update c v p in
        get_coloring_aux peo c
      | None => None
      end
    end
  in
  get_coloring_aux (rev peo) Coloring.empty.
\end{lstlisting}

\section{SSA Destruction}
\label{sec:destruct}

The final phase before emitting assembly is SSA destruction, which consists in the translation of $\phi$-instructions into moves. This final phase is required since $\phi$-instructions are not implemented in common architectures.
We mentioned in \Cref{subsec:phi} that a section of $\phi$-instructions behaves as a parallel copy, our goal is to find a sequence of instruction that preserves this property. The translation is straightforward for some cases, take the following example, where $x \to y$ represents moving the content of register $x$ to register $y$:
\[
  r_1 \to r_2, r_2 \to r_3, r_3 \to r_4
\]
Solving this problem basically consists in reordering the moves so that no value is overwritten, the solution for this case is:
\[
  r_3 \to r_4, r_2 \to r_3, r_1 \to r_2
\]
Unfortunately some other cases are non-trivial, namely those who contain loops such as:
\[
  r_1 \to r_2, r_2 \to r_3, r_3 \to r_1
\]
There are two ways of solving these cases, we could try to find a sequence of swap operations such that at the end of the computation each value ends up in the intended register, this first option could be implemented using a swap instruction (like \texttt{xchg}) if supported by the architecture, or by using the XOR operator. Another option would be to reserve a special register \texttt{tmp} to perform the swaps. In our implementation we use an already verified algorithm~\cite{Rideau-Serpette-Leroy-parmov} that uses temporary variables. Given the previous example we would end up with the following result:
\[
  r_1 \to \texttt{tmp}, r_3 \to r_1, r_2 \to r_3, \texttt{tmp} \to r_2
\]
Now that we are able to compile a parallel move we visit the \gls{cfg} while translating one section of $\phi$-instructions at a time.
We identify three different cases when performing the destruction, one for each jump instruction:
\begin{itemize}
  \item When visiting a basic block that ends with a \texttt{CondJump} we need to translate two different parallel moves, one for each of the two successors, since we cannot append two different parallel move translations into the current block, as they would conflict with each other, we need to create two new basic blocks, each of which contains the corresponding translation of the parallel move and then an unconditional jump to the successor. We also give them the same label as the current block but, this time, we use constructors \texttt{Point1} and \texttt{Point2} to avoid a collision with the current block, which uses the \texttt{Normal} constructor;
  \item If instead we encounter a jump instruction, the translation simply consists in appending the translated parallel move at the end of the instructions of the current block;
  \item Finally the return instruction does not require any translation, as it is the last instruction of a program;
\end{itemize}

In \Cref{fig:destruct} we can see an example of SSA destruction in action, in the visit first we encounter an unconditional jump, then a conditional jump and finally a return instruction.

\begin{figure}[h]
\centering
\begin{minipage}{0.45\textwidth}
\centering
  \begin{tikzpicture}[
      node distance=10mm,
      every node/.style={draw, align=left, inner sep=4pt},
      >={Stealth}
    ]
    \node (entry)   at (0, 0)   {$r_0 \leftarrow 0$};
    \node (loop)    at (0, -2)  {$r_1 \leftarrow \phi(r_0, r_2)$ \\ $r_2 \leftarrow r_1 + 1$};
    \node (end)     at (0, -4)  {ret $r_2$};
    \draw[->] (entry) -- (loop);
    \draw[->] ([xshift=10pt]loop.south) to[out=315, in=45, looseness=8] ([xshift=10pt]loop.north);
    \draw[->] (loop) -- (end);
    \end{tikzpicture}
\end{minipage}
\hfill
\begin{minipage}{0.45\textwidth}
\centering
  \begin{tikzpicture}[
      node distance=10mm,
      every node/.style={draw, align=left, inner sep=4pt},
      >={Stealth}
    ]
    \node (entry)   at (0, 0)     {$r_0 \leftarrow 0$ \\ $r_1 \leftarrow r_0$};
    \node (loop)    at (0, -2)    {$r_2 \leftarrow r_1 + 1$};
    \node (loop1)   at (-1.5, -4) {nop};
    \node (loop2)   at (1.5, -4)  {$r_1 \leftarrow r_2$};
    \node (end)     at (0, -6)    {ret $r_6$};
    \draw[->] (entry) -- (loop);
    \draw[->] (loop) -- (loop1);
    \draw[->] (loop) -- (loop2);
    \draw[->] (loop2.south) to[out=315, in=45, looseness=3] ([xshift=10pt]loop.north);
    \draw[->] (loop1) -- (end);
    \end{tikzpicture}
\end{minipage}
\caption{SSA destruction of a loop.}
\label{fig:destruct}
\end{figure}

\todo{Add description of registers implementation either in \Cref{sec:jair} or \Cref{cha:verification}}