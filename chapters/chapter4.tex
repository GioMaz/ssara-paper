% Errors

\chapter{\glsentrylong{ra}}
\label{cha:ra}

\section{Liveness Analysis}
\label{sec:liveness}

In this phase, we compute the set of live variables at each program point. This step is crucial for determining which variables interfere and, therefore, constitute an edge of the interference graph.

Generally a liveness analysis algorithm works this way:
we start from the last instruction of the program and go back to the start instruction in a post-order fashion, while we do that we compute the following sets for each instruction $i$:
\begin{itemize}
  \item LiveIn[$i$] which contains the variables that are live \textit{before} the execution of instruction $i$;
  \item LiveOut[$i$] which instead contains the variables live \textit{after} the execution of $i$;
  \item Def[$i$] are the variables created by the instruction, in our language this set is either a singleton or the empty set as we can only define at most one variable per instruction;
  \item Use[$i$] are the variables used as arguments by the instruction, at most two in our language since that is the maximum arity of our expressions.
\end{itemize}

Since in our language instructions can be of three different kinds we define different dataflow equations for each instruction type.

We start by defining the dataflow equations for the ALU-instructions:
\begin{align*}
  \text{LiveIn}[i] &= \text{Use}[i] \cup (\text{LiveOut}[i] \setminus \text{Def}[i]) \\
  \text{LiveOut}[i] &= \bigcup \limits_{j \in \text{Succ[i]}} \text{LiveIn}[j]
\end{align*}

Since the computation is done backwards we start with the LiveOut[$i$] set, which must contain the variables that are required by the successors of $i$. The
LiveIn[$i$] set must instead contain the variables required by $i$, identified by Use[$i$] and the variables that are required by the next instructions, identified by LiveOut[$i$] $\setminus$ Def[$i$].
Here there are some things to note, first of all that the set LiveOut[$i_n$] = $\emptyset$ where $i_n$ is the last instruction of the program, since no variables are live after the program ends, we start from this assumption at the beginning of the procedure.

For jump instructions instead, the dataflow equations are similar, we just simplify the first dataflow equation by removing Def[$i$] as jump instructions never define variables.

Now, because of the different semantics of $\phi$-instructions we must define their dataflow equations separately. In particular, we define the liveness information of the whole section $\Phi$, instead of for single $\phi$-instructions. This is because, as was explained in \Cref{sec:ssa}, these instructions are executed parallelly.
We compute:
\begin{align*}
  \text{LiveIn}[\Phi] &= \text{PhiDefs}[\Phi] \cup \text{LiveOut}[\Phi] \\
  \text{LiveOut}[\Phi] &= \bigcup \limits_{j \in \text{Succ}[\Phi]} \text{LiveIn}[j]
\end{align*}

Where PhiDefs[$\Phi$] contains the left-hand sides of the $\phi$-instructions.

Starting again with LiveOut[$\Phi$], we define it as the union of the variables that are live before the first ALU-instruction of the block. LiveIn[$\Phi$] is instead the set of variables that are defined in the $\phi$-instructions together with the variables that are required after the $\phi$-instructions, intuitively the variables in PhiDefs[$\Phi$] are already defined before reaching the start of the block since their execution happens during the jump.

\section{Register Assignment}
\label{sec:ra}

% As explained in \Cref{subsec:ssara} register assignment is considered equivalent to the task of graph coloring of the interference graph. Before starting with the coloring let's recall \Cref{def:ig}. A chordal graph is a graph for which there exists a \gls{peo}, that is, there exists a simplicial node such that, if we remove that node the graph is still chordal. The \gls{peo} is then the ordering in which those nodes are removed.

In order to perform \gls{ra} we use the approach presented by Hack-Grund-Goos~\cite{HGG:2006:RA-SSA}. We detail the implementation in different sections:
\begin{itemize}
  \item In \Cref{subsec:ig}, we use the liveness information, obtained from the liveness analysis step, to build the interference graph;
  \item In \Cref{subsec:peo}, we iteratively remove the simplicial nodes from the interference graph obtaining a \gls{peo};
  \item Finally, in \Cref{subsec:coloring}, we reinsert the nodes of the \gls{peo} in \textit{reverse} order into the interference graph. While doing that, we assign them a color that is not already taken by their neighborhoods.
\end{itemize}

\subsection{Building the Interference Graph}
\label{subsec:ig}

After extracting the liveness information from our \gls{cfg}, we use it to build the interference graph.
The reasoning behind the creation of the interference graph is straightforward. We go through every live set computed during the liveness analysis, and we insert it as a clique in the interference graph. This follows intuitively by the fact that, if two variables are live in the same instruction, then they interfere, as stated in \Cref{def:ig}.

The function used to populate the interference graph is the following:

\begin{lstlisting}[style=Rocq]
Definition get_ig (pi : ProgramInfo.dict) : InterfGraph.dict :=
  fold_left
    (fun g l =>
      match ProgramInfo.get pi l with
      | Some (BlockInfo iis) => ig_insert_instinfos g iis
      | None => g
      end)
    (ProgramInfo.keys pi)
    InterfGraph.empty.
\end{lstlisting}

At line 5, we call \texttt{ig\_insert\_instinfos}. This function, given an interference graph and a list of live sets, returns a graph where a clique is added for each live set of the list.

\subsection{Obtaining a \glsentrylong{peo}}
\label{subsec:peo}

Recalling \Cref{def:simplicial} we implement a function that determines whether a node of a graph is simplicial:

\begin{lstlisting}[style=Rocq]
Definition is_simplicialb (g : InterfGraph.dict) (r : reg) : bool :=
  regs_mem r (InterfGraph.keys g) &&
  is_cliqueb g (InterfGraph.get g r ).
\end{lstlisting}

At line 2, we check that \texttt r is actually part of the graph using \texttt{regs\_mem}. At line 3, we check whether the neighborhood of \texttt r is a clique, using \texttt{is\_cliqueb}.
We now define a function that lets us find any simplicial node in a graph:

\begin{lstlisting}[style=Rocq]
Definition find_next (g : InterfGraph.dict) : option reg :=
  find (is_simplicialb g) (InterfGraph.keys g).
\end{lstlisting}

Here, we find the first node of the graph that respects the \texttt{(is\_simplicialb g)} condition. Note that the output node is an optional value, since the function may also receive a non-chordal graph which may not have a simplicial node. Because of that, we need to propagate the option wrapper to all the return values of the subsequent functions.
As shown in \Cref{cha:extraction}, upon receiving a \texttt{None} constructor, we throw an exception, signaling to the user that the interference graph (and likely even the initial \gls{jair} program) is ill-formed.

Now we define one step of the \texttt{eliminate} function, namely \texttt{eliminate\_step}:

\begin{lstlisting}[style=Rocq]
Definition eliminate_step
  (g : InterfGraph.dict) : option (reg * InterfGraph.dict):=
  match find_next g with
  | Some next =>
    Some (next, ig_remove_node g next)
  | None => None
  end.
\end{lstlisting}

This function takes an interference graph (which is chordal), and finds a simplicial node, removes it, and returns both the removed node and the resulting graph.
Note that, as we prove in \Cref{lem:inv-elim-2}, if the input graph is chordal and non-empty, the function will never return the \texttt{None} constructor. Furthermore, the resulting graph will also be chordal.

Now we define the \texttt{eliminate} function, that is, the function for obtaining a \gls{peo}:

\begin{lstlisting}[style=Rocq]
Function eliminate
  (g : InterfGraph.dict) {measure InterfGraph.size g} : list reg :=
  match eliminate_step g with
  | Some (next, g') => next :: (eliminate g')
  | None => nil
  end.
\end{lstlisting}

The definition of the function is straightforward. We take an interference graph, and we remove the simplicial nodes until we obtain the empty graph. At each recursive call, we append the removed node at the end of the list.
As was mentioned in \Cref{subsec:funterm}, Rocq has trouble automatically verifying the termination of this function. This forces us to introduce the annotation \texttt{{measure InterfGraph.size g}}. This tells Rocq that the decreasing property lies in the size of the interference graph. We will also prove this in \Cref{thm:term-elim}.

\subsection{Coloring}
\label{subsec:coloring}

Before talking about the algorithm~\cite{HGG:2006:RA-SSA} mentioned at the beginning of \Cref{sec:ra}, we make the following assumptions:

\begin{assumption}\label{ass:ig1}
The interference graph $G$ obtained from the liveness analysis is chordal, which we know from \Cref{thm:chordal-chromatic}.
\end{assumption}

\begin{assumption}\label{ass:ig2}
The chromatic number $\omega(G)$ is less than or equal to the number of available registers $k$. That is, we assume that spilling already happened, making the graph $k$-colorable.
\end{assumption}

Now consider a single iteration of the algorithm~\cite{HGG:2006:RA-SSA} mentioned at the beginning of \Cref{sec:ra}. Given \Cref{ass:ig1}, we are able to find a simplicial node $u$. This means that the neighborhood of $u$ forms a clique. Even if not every element of the neighborhood is colored, the colored neighbors still form a clique (a subset of a clique is still a clique). The next step consists in finding a color that is not used by the colored neighbors, which is always possible, because of \Cref{ass:ig2}.

Given this intuition, we start with the definition of the \texttt{Coloring} object. This is a map from virtual registers to physical registers and will be the output of the coloring phase.

At each position of the \textit{reversed} \gls{peo}, we find a node whose colored neighborhood forms a clique. Because of that, in order to assign this node a new color, we pick a random one from the complement of the neighborhood colors. We define a function specifically for this purpose.

\begin{lstlisting}[style=Rocq]
Definition preg_compl (colors : set preg) : option preg :=
  match IRPreg.regs_diff preg_allowed colors with
  | nil => None
  | c :: _ => Some c
  end.
\end{lstlisting}

Here, given a set of registers we calculate its difference with the set of registers in \texttt{preg\_allowed}. The variable \texttt{preg\_allowed} contains the registers that can be used during the coloring. Note that the result of this function is optional, since if we run out of registers, we are not able to extract a color. However, this cannot happen due to \Cref{ass:ig2}.

Now we use the function we just defined to find the color of a node given its interference graph and the current coloring:

\begin{lstlisting}[style=Rocq]
Definition get_color
  (v : IRVreg.reg)
  (g : InterfGraph.dict)
  (c : Coloring.dict)
  : option IRPreg.reg :=
  let nbors := InterfGraph.get g v in
  let used  := map (Coloring.get c) nbors in
  preg_compl used.
\end{lstlisting}

At line 6, we find the neighborhood of the node. At line 7, we map each neighbor to its assigned color and, at line 8, we extract an unused color.

We introduce the function to obtain the complete coloring of the interference graph, the procedure is the same as explained at the beginning of \Cref{subsec:coloring}.

\begin{lstlisting}[style=Rocq]
Fixpoint get_coloring_aux
  (peo : list IRVreg.reg)
  (g : IFG.dict)
  (c : Coloring.dict)
  : option Coloring.dict :=
  match peo with
  | nil => Some c
  | v :: peo =>
    match get_color v g c with
    | Some p => get_coloring_aux peo g (Coloring.update c v p)
    | None => None
    end
  end.
\end{lstlisting}

At line 6, we extract the head of the \gls{peo}. We then color it with the \texttt{get\_color} function. If a color is found, we proceed with a recursive call on the rest of the \gls{peo}. Otherwise, we return the \texttt{None} constructor.
The \texttt{get\_coloring\_aux} function requires some specific parameters to be passed initially. In particular, it must be provided with a \textit{reversed} \texttt{peo}, and an empty coloring. We define these parameters in the wrapper \texttt{get\_coloring}.

\begin{lstlisting}[style=Rocq]
Definition get_coloring
  (peo : list IRVreg.reg)
  (g : InterfGraph.dict)
  : option Coloring.dict :=
  get_coloring_aux (rev peo) g Coloring.empty.
\end{lstlisting}

After obtaining \texttt{Coloring} map, we visit the \gls{cfg}, and we color each register we encounter. We do that with the \texttt{color\_program} function.

\begin{lstlisting}[style=Rocq]
CoFixpoint color_program (c : Coloring.dict) (p : IRVreg.program)
  : IRPreg.program :=
  match p with
  | IRVreg.Block l ps is j =>
    IRPreg.Block l

    (* Color phi-instructions *)
    (map (color_phi c) ps)

    (* Color ALU-instructions *)
    (map (color_inst c) is)

    (match j with
    (* Color the conditional jump and the successor blocks *)
    | IRVreg.CondJump c' r v b1 b2 =>
      IRPreg.CondJump c'
      (Coloring.get c r)
      (color_val c v)
      (color_program c b1)
      (color_program c b2)

    (* Color the unconditional jump and the successor block *)
    | IRVreg.Jump b => IRPreg.Jump (color_program c b)

    (* Color the return register *)
    | IRVreg.Ret r => IRPreg.Ret (Coloring.get c r)
    end)
  end.
\end{lstlisting}

This function takes a coloring, a program using virtual registers, and returns a program using physical registers. At line 8, we color each $\phi$-instruction with function \texttt{color\_phi}. We do the same for the ALU-instructions at line 10. Instead, at line 13, we match with the different cases of jump instructions, color their arguments, and then color the successors with a recursive call.

In the \texttt{color\_program} function, lies the reason why we introduced the \texttt{UNASSIGNED} constructor in the physical register type. Assume, in fact, that instead of using that constructor, we used an \texttt{option} to wrap the return type of the \texttt{Coloring} map. Because of that, \texttt{Coloring} would become a partial map, rather than a total map. This would force us to return optional values in \texttt{color\_phi}, \texttt{color\_inst}, and even \texttt{color\_program}. However, because the latter is a \texttt{CoFixpoint} function, as defined in \Cref{subsec:coind}, its return type must be \texttt{CoInductive}. However, this is not the case for the \texttt{option} type.

\section{SSA Destruction}
\label{sec:destruct}

The final phase before emitting assembly is SSA destruction. SSA destruction translate $\phi$-instructions into register copies. This is required since $\phi$-instructions are not implemented in common hardware architectures.
To convert each sequence of $\phi$-instructions, we use the algorithm proposed by Rideau-Leroy~\cite{Rideau-Leroy-regalloc}, implemented in the \texttt{pmove} function. This function has signature \texttt{moves $\to$ moves}, where \texttt{moves} is a list of pairs of registers \texttt r and \texttt{r'}, the sources and destinations of the copy respectively.
Because we do not introduce a proof of termination for the algorithm, we pass \texttt{fuel} as an argument of the subsequent functions.

We then define \texttt{succ\_to\_insts}. This function takes the current block label, a successor block, and \texttt{fuel}. Then, it returns a sequence of register copies semantically equivalent to the ones specified by the $\phi$-instructions of the successor.

\begin{lstlisting}[style=Rocq]
Definition succ_to_insts (curr : lbl) (succ : block) (fuel : nat)
  : list inst :=
  let ms := phis_to_moves curr (get_phis succ) in
  let ms := pmove ms fuel in
  moves_to_insts ms.
\end{lstlisting}

Here, at line 3, we convert the $\phi$-instructions of the successor into simple moves. At line 4, we apply the translation algorithm passing the \texttt{fuel} parameter and the moves we just computed. At the end of the function, we return the moves as \gls{jair} instructions.
The following, is the function for performing \gls{ssa} destruction of the \gls{cfg}.

\begin{lstlisting}[style=Rocq]
Definition ssa_destruct (fuel : nat) (b : block) :=
  let cofix ssa_destruct_aux (curr: lbl) (b : block) : block :=
    match b with
    | Block l ps is j =>
      match j with
      | CondJump c r v b1 b2 =>
        Block l [] is (CondJump c r v
          (Block
            (Point1 (nat_of_lbl l)) [] (succ_to_insts l b1 fuel)
            (Jump (ssa_destruct_aux l b1)))
          (Block (Point2 (nat_of_lbl l)) [] (succ_to_insts l b2 fuel)
            (Jump (ssa_destruct_aux l b2))))
      | Jump b' =>
        Block l [] (is ++ (succ_to_insts l b' fuel))
          (Jump (ssa_destruct_aux l b'))
      | Ret r =>
        Block l [] is (Ret r)
      end
    end
  in
  ssa_destruct_aux (get_lbl b) b.
\end{lstlisting}

We identify three different cases when performing the destruction, one for each constructor of the jump instruction. At line 6, we handle the case of a \texttt{CondJump}. Here, we need to translate two different parallel moves, one for each of the two successors. In this case, we cannot append the two different parallel move translations at the end of the current block. If we did, they would conflict with each other. Because of that, we need to create two new basic blocks, namely \texttt{(Point1 l)} and \texttt{(Point2 l)}. Where \texttt l is the label of the current block. Each of the two new blocks contain the result of \texttt{succ\_to\_insts} and a jump instruction to the successor.

The second case, at line 13, is the unconditional \texttt{Jump}. The translation simply consists in appending the result of \texttt{succ\_to\_insts} at the end of the instructions of the current block. Maintaining the unconditional jump at the end of the block.

The last case, at line 14, handles the \texttt{Ret} instruction. This case does not require any translation, as it is the last instruction of a program.


% We mentioned in \Cref{sec:ssa} that a sequence of $\phi$-instructions behaves as a parallel copy, our goal is to find a sequence of register instruction that preserves this property. The translation is straightforward for some cases, take the following example, where $x \to y$ represents moving the content of register $x$ to register $y$:
% \[
%   r_1 \to r_2, r_2 \to r_3, r_3 \to r_4
% \]
% Solving this problem basically consists in reordering the moves so that no value is overwritten, the solution for this case is:
% \[
%   r_3 \to r_4, r_2 \to r_3, r_1 \to r_2
% \]
% Unfortunately some other cases are non-trivial, namely those who contain loops such as:
% \[
%   r_1 \to r_2, r_2 \to r_3, r_3 \to r_1
% \]
% There are two ways of solving these cases, we could try to find a sequence of swap operations such that at the end of the computation each value ends up in the intended register, this first option could be implemented using a swap instruction (like \texttt{xchg}) if supported by the architecture, or by using the XOR operator. Another option would be to reserve a special register \texttt{tmp} to perform the swaps. In our implementation we use an already verified algorithm~\cite{Rideau-Serpette-Leroy-parmov} that uses temporary variables. Given the previous example we would end up with the following result:
% \[
%   r_1 \to \texttt{tmp}, r_3 \to r_1, r_2 \to r_3, \texttt{tmp} \to r_2
% \]
% Now that we are able to compile a parallel move we visit the \gls{cfg} while translating one section of $\phi$-instructions at a time.

%TODO: MOVE THIS IN BACKGROUND
In \Cref{fig:destruct} we see an example of SSA destruction in action. The branch instruction at the end of $B_1$ introduces two additional blocks, $B_{1.1}$ and $B_{2.2}$. Additionally, the original $\phi$-instruction highlighted in block $B_1$ is translated into the instructions highlighted in blocks $B_{1.2}$ and \textbf{start}. Instead, in block $B_{1.1}$ no register copy is required, as the return argument in $B_2$ is already in $r_2$.

\begin{figure}[ht]
\begin{minipage}{0.45\textwidth}
\centering
  \begin{tikzpicture}[
      node distance=10mm,
      every node/.style={draw, align=left, inner sep=4pt},
      >={Stealth}
    ]
    \node (entry)   at (0, 0)   [draw, label=above:\textbf{start}] {$r_0 \leftarrow 0$};
    \node (loop)    at (0, -2)  [draw, label=left:$B_1$] {\colorbox{yellow!40}{$r_1 \leftarrow \phi(r_0, r_2)$} \\ $r_2 \leftarrow r_1 + 1$};
    \node (end)     at (0, -4)  [draw, label=left:$B_2$] {ret $r_2$};
    \draw[->] (entry) -- (loop);
    \draw[->] ([xshift=10pt]loop.south) to[out=315, in=45, looseness=8] ([xshift=10pt]loop.north);
    \draw[->] (loop) -- (end);
    \end{tikzpicture}
\end{minipage}
\hfill
\begin{minipage}{0.45\textwidth}
  \centering
  \begin{tikzpicture}[
      node distance=10mm,
      every node/.style={draw, align=left, inner sep=4pt},
      >={Stealth}
    ]
    \node (entry)   at (0, 0)     [draw, label=above:\textbf{start}] {$r_0 \leftarrow 0$ \\ \colorbox{yellow!40}{$r_1 \leftarrow r_0$}};
    \node (loop)    at (0, -2)    [draw, label=left:$B_1$] {$r_2 \leftarrow r_1 + 1$};
    \node (loop1)   at (-1.5, -4) [draw, label=left:$B_{1.1}$] {nop};
    \node (loop2)   at (1.5, -4)  [draw, label=left:$B_{1.2}$] {\colorbox{yellow!40}{$r_1 \leftarrow r_2$}};
    \node (end)     at (0, -6)    [draw, label=left:$B_2$] {ret $r_2$};
    \draw[->] (entry) -- (loop);
    \draw[->] (loop) -- (loop1);
    \draw[->] (loop) -- (loop2);
    \draw[->] (loop2.south) to[out=315, in=45, looseness=3] ([xshift=10pt]loop.north);
    \draw[->] (loop1) -- (end);
    \end{tikzpicture}
\end{minipage}
  \caption{Left: \gls{cfg} before \gls{ssa} destruction. Right: the same \gls{cfg} after \gls{ssa} destruction.}
  \label{fig:destruct}
\end{figure}
  % \caption{The \gls{cfg} before and after \gls{ssa} destruction. Note that blocks $B_{1.1}$ and $B_{2.2}$ have been added, and that the $\phi$-instruction was translated into copies (marked yellow).}
