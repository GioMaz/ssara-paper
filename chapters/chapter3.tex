% Errors

\chapter{\gls{jair}}
\label{cha:jair}

In this chapter, we provide an overview of the design and implementation choices that guided the development of the register assignment pipeline and the underlying language \gls{jair}. The implementation is structured in a modular way, beginning with the definition of the syntax and semantics of the language. We then detail the steps of register assignment, namely liveness analysis, graph coloring, and \gls{ssa} destruction.

\section{The \gls{jair} Syntax}
\label{sec:jair}

The primary goal in defining the syntax of \gls{jair} is to leverage the type system of Rocq to rule out as many ill-formed \gls{ssa} programs as possible, as discussed in \Cref{sec:ssa}. We begin by describing how registers are represented in our language.

\subsection{Registers}

Our implementation uses two kinds of registers: virtual registers in the earlier phases of register assignment, and physical registers in the final phase. To support both use cases, we define \texttt{IR} module, which defines the syntax of our intermediate representation generically over these two types of registers.

The module requires the following parameters:
\begin{itemize}
    \item The register type \texttt{reg}, the set of all the registers we can choose from;
    \item The boolean equality function for the register type, namely \texttt{reg\_eqb};
    \item A proof for the decidability of the logical equality for the register type, namely \texttt{reg\_eq\_dec};
\end{itemize}

For virtual registers, we use the set of natural numbers, which, although bounded by Rocq's runtime limits, can be treated as unbounded for our purposes.

\begin{lstlisting}[style=Rocq]
Definition vreg := nat.
\end{lstlisting}

For physical registers, instead, we define a finite set that corresponds to the 64-bit general-purpose registers of the x86-64 architecture.

\begin{lstlisting}[style=Rocq]
Inductive preg : Type :=
  | RAX
  | RBX
  | RCX
  (* ... *)
  | UNASSIGNED
.
\end{lstlisting}

We also include the \texttt{UNASSIGNED} register, this register is used as a default value for the coloring, removing the need of returning an optional value everywhere. Later we will prove that the coloring function will never return this constructor.

Throughout the implementation, every register is understood to be either virtual or physical depending on the phase of the compilation pipeline.

\subsection{Labels}

Initially, we opted for a label-less representation of basic blocks.
Later in the project we saw the necessity of introducing them for this specific reason: the $\phi$-instructions require labels to identify the incoming control flow since predecessors of a basic blocks are not ordered. Without labels a $\phi$-instruction would not know which one of the predecessors each of its arguments is bound to.

An alternative solution would be (given the single definition policy of \gls{ssa}) to go back in the control flow to find which of the arguments of the $\phi$-instruction is defined. This approach proved too complicated, so we adopted labels, at the cost of introducing possible inconsistencies in the representation that we will later discuss in \Cref{subsec:limitations}.

\begin{lstlisting}[style=Rocq]
Inductive lbl : Type :=
  | Normal : nat -> lbl
  | Point1 : nat -> lbl
  | Point2 : nat -> lbl.
\end{lstlisting}

The label type is defined with three constructors. The reason is explained more in detail in \Cref{sec:destruct}, but for now let's just say that the \gls{ssa} destruction phase introduces additional basic blocks (at most two for each preexisting basic block). With the constructors \texttt{Point1} and \texttt{Point2} we identify these additional basic blocks in order to avoid collisions, whereas with the \texttt{Normal} constructor we identify the blocks that already existed before the destruction phase.

\subsection{ALU Instructions}

In order to perform computations, our intermediate representation must provide arithmetical and logical instructions.
We start by defining the \texttt{val} type which represents an operand of these instructions. It can be either an immediate integer, a register, or a pointer to a memory location (represented by a natural number):

\begin{lstlisting}[style=Rocq]
Inductive val : Type :=
  | Imm (x : Z)
  | Reg (r : reg)
  | Ptr (p : nat).
\end{lstlisting}

We then define the type of expressions \texttt{expr}. These include register copies, memory loads, and arithmetical and logical operations. Expression depth is restricted to avoid unnecessary complexity and to preserve the linearity of the data structure.

\begin{lstlisting}[style=Rocq]
Inductive expr : Type :=
  | Val : val -> expr
  | Load : val -> expr
  | Add : reg -> val -> expr
  | Sub : reg -> val -> expr
  (* ... *)
.
\end{lstlisting}

As can be seen from the previous snippet, binary expressions always use a register as the first operand, preventing expressions that involve only constants since, in that case, the result could be computed during a previous step of constant folding. Another thing to note is that, for the sake of register assignment, a differentiation between unary, binary and $n$-ary expressions is unnecessary, as we are only concerned with the identities of the operands of an expression (the registers) and not the operators.

Finally, the instruction type \texttt{inst} reflects the core operations in our language. Instructions either define a register by assigning to it the result of an expression, or store a value into memory:

\begin{lstlisting}[style=Rocq]
Inductive inst : Type :=
  | Def (r : reg) (e : expr)
  | Store (v : val) (r : reg).
\end{lstlisting}

The \texttt{Store} instruction is treated specially because it does not produce a result that can be assigned to a register. Therefore, it cannot be expressed as a \texttt{Def}.

\subsection{$\phi$-Instructions}

In \Cref{sec:ssa} we defined a section of $\phi$-instructions as a parallel move based on the predecessor in the control flow.
We need an implementation that preserves this definition, to do so we start by defining the type of an argument of a $\phi$-instruction, namely \texttt{phi\_arg}.

\begin{lstlisting}[style=Rocq]
Definition phi_arg : Type := (reg * lbl).
\end{lstlisting}

Semantically the \texttt{reg} instance is the source of the copy if the control flow comes from the \texttt{lbl} instance.

Finally, we define $\phi$-instruction type, this is simply an assignment of one of the possible \texttt{phi\_arg}s to a destination \texttt{reg}.

\begin{lstlisting}[style=Rocq]
Inductive phi : Type :=
| Phi : reg -> list phi_arg -> phi.
\end{lstlisting}

% Here, each \texttt{phi\_arg} pairs a register with a label identifying the originating block. Initially, we experimented with a label-free control flow representation that used direct pointers to blocks. However, as we will explain later, this made the semantics unnecessarily difficult to define, leading us to prefer label-based control flow.

\subsection{Blocks and Jump Instructions}

ALU instructions and $\phi$-instructions are defined separately enforcing the fact that in basic blocks the $\phi$-instructions appear first, followed by ALU instructions and finally by a jump instruction.
We define the jump instruction type in mutual recursion with the block type.

\begin{lstlisting}[style=Rocq]
CoInductive block : Type :=
  | Block (l : lbl) (ps : list phi) (is : list inst) (j : jinst)
with jinst : Type :=
  | CondJump : cond -> reg -> val -> block -> block -> jinst
  | Jump : block -> jinst
  | Ret : reg -> jinst.
\end{lstlisting}

Control flow is encoded directly using block references instead of labels, preventing accidental jumps to nonexistent blocks. This definition naturally forms a control-flow graph, where blocks are nodes and jump instructions define the edges.

Finally, a \gls{cfg} as we described in \Cref{subsec:cfg} is a set of blocks where we identify a start block and a control flow relation, it is sufficient to provide the following definition:

\begin{lstlisting}[style=Rocq]
Definition program : Type := block.
\end{lstlisting}

Where the starting point of the \gls{cfg} is the first block we encounter during a visit and the blocks set of the \gls{cfg} is the set of blocks reachable from the first block.

Now that we covered the main parts of the \gls{jair} implementation, we demonstrate the capabilities of our representation in \Cref{fig:example-jair} with an example of the Fibonacci function along with the same example in a \gls{ssa} form representation.

\begin{figure}[ht]
\centering
\begin{minipage}{0.65\textwidth}
\begin{lstlisting}[style=Rocq]
Definition example_block_3 : block :=
  Block (Normal 3) [] [] (ret r(6)).

CoFixpoint example_block_2 : block :=
  Block (Normal 2) [
    r(3) <- phi [(0, Normal 1); (4, Normal 2)];
    r(4) <- phi [(1, Normal 1); (6, Normal 2)];
    r(5) <- phi [(2, Normal 1); (7, Normal 2)]
  ] [
    r(6) <- r(4) + r(3);
    r(7) <- r(5) - i(1)
  ] (
    if r(7) = i(1)
    then example_block_3
    else example_block_2
  ).

Definition example_block_1 : block :=
  Block (Normal 1) [] [
    r(0) <- i(0);  (* Second temp *)
    r(1) <- i(1);  (* First temp *)
    r(2) <- i(12)  (* Iterator *)
  ] (
    Jump example_block_2
  ).
\end{lstlisting}
\end{minipage}
\hfill
\begin{minipage}{0.30\textwidth}
\centering
\begin{tikzpicture}[
    node distance=10mm,
    every node/.style={draw, align=left, inner sep=4pt},
    >={Stealth}
]
  \node (entry)   at (0, 0)   {$r_0 \leftarrow 0$ \\ $r_1 \leftarrow 1$ \\ $r_2 \leftarrow 12$};
  \node (loop)    at (0, -3)  {$r_3 \leftarrow \phi(r_0, r_4)$ \\ $r_4 \leftarrow \phi(r_1, r_6)$ \\ $r_5 \leftarrow \phi(r_2, r_7)$ \\ $r_6 \leftarrow r_4 + r_3$ \\ $r_7 \leftarrow r_5 - 1$};
  \node (end)     at (0, -5.5)  {ret $r_6$};
  \draw[->] (entry) -- (loop);
  \draw[->] ([xshift=10pt]loop.south) to[out=315, in=45, looseness=4] ([xshift=10pt]loop.north);
  \draw[->] (loop) -- (end);
\end{tikzpicture}
\end{minipage}
\caption{Code for the Fibonacci function in \gls{jair} along with the same code in a \gls{ssa} form representation}
\label{fig:example-jair}
\end{figure}

\subsection{Limitations}
\label{subsec:limitations}

Despite our efforts to use Rocq's type system to rule out incorrect programs, certain ill-formed programs cannot be excluded purely by the syntax, we now provide examples of such cases.

A fundamental problem is that the two core policies of an \gls{ssa} form representation are not enforced, namely multiple assignments to the same register and the use of undefined registers are still possible:

\begin{lstlisting}[style=Rocq]
Definition double_assignment : block :=
  Block (Normal 0) [] [
    r(1) <- i(0);
    r(1) <- i(1)
  ]
  (ret r(1)).

Definition undefined_variable : block :=
  Block (Normal 0) [] [r(1) <- r(0)] (ret r(1)).
\end{lstlisting}

Similarly, uniqueness of labels is not enforced, which can lead to conflicting block labels, as shown in the following example:

\begin{lstlisting}[style=Rocq]
CoFixpoint double_lbl_1 : block :=
  Block (Normal 0) [] [] (Jump double_lbl_2)
with double_lbl_2 : block :=
  Block (Normal 0) [] [] (Jump double_lbl_1).
\end{lstlisting}

Finally, $\phi$-instructions may include inconsistent or invalid arguments. For example, the number of the predecessors listed in a $\phi$-instruction may not match the actual number of predecessors:

\begin{lstlisting}[style=Rocq]
Definition ill_formed_phi_2 : block :=
  Block (Normal 1) [
    r(1) <- phi [(1, 5); (2, 6); (3; 7)]] [] (ret r(0)).
Definition ill_formed_phi_1 : block :=
  Block (Normal 0) [] [] (Jump ill_formed_phi_2).
\end{lstlisting}

Although these issues cannot be resolved by the type system alone, they can be caught during a previous semantic analysis phase.

\section{A \gls{jair} Interpreter}
\label{sec:jair-int}

We now implement a small-step interpreter for our intermediate representation, we do this for two reasons.
The first one is to clearly state the semantics of \gls{jair}. The second one is that, in order to test register assignment, we will compare the result of a program executed on the interpreter virtual machine with the result of the same program executed on bare hardware, if the two results match this will suggest that the semantics of the program are preserved even after register assignment.
The definition of the virtual machine is straightforward as its components are just the register file, implemented as a map from registers to integers, and the memory, implemented as list of integers.

\begin{lstlisting}[style=Rocq]
Inductive vm : Type :=
  | Vm : (reg -> Z) -> list Z -> vm.
\end{lstlisting}

After defining the virtual machine, we define the primitives to interact with it. We begin with operations on the register file.

The function to read a value from a register is defined as follows:

\begin{lstlisting}[style=Rocq]
Definition get_reg (m : vm) (r : reg) : cell :=
  match m with
  | Vm regs _ => regs r
  end.
\end{lstlisting}

This function takes a virtual machine state \texttt m and a register \texttt r, and returns the content of the register  by performing $\beta$-reduction on the register file map.

The corresponding function to write a value into a register is defined as:

\begin{lstlisting}[style=Rocq]
Definition set_reg (m : vm) (r : reg) (c : cell) : vm :=
  match m with
  | Vm regs cells =>
    Vm (fun r' => if r' =? r then c else regs r') cells
  end.
\end{lstlisting}

Here, we take the current register file map, and we wrap it with a lambda function, if the argument of that function matches register \texttt r, we return the value \texttt c, otherwise we perform $\beta$-reduction with the previous version of the register file map.

Now, we define analogous operations for memory access. In our implementation memory does not support random access, instead, we use a list that grows whenever a new value is stored, filling the previously uninitialized memory locations with zeroes. The function to retrieve the content of a memory location is defined as follows:

\begin{lstlisting}[style=Rocq]
Definition get_cell (m : vm) (i : nat) : cell :=
  let fix get_cell_aux (cells : list cell) (i : nat) : cell :=
    match cells, i with
    | nil, _ => Z0
    | c :: _, O => c
    | _ :: cs, S i' => get_cell_aux cs i'
    end
  in
  match m with
  | Vm _ cells => get_cell_aux cells i
  end.
\end{lstlisting}

The recursive function considers three cases:
\begin{itemize}
  \item If the memory is empty, then the value we are trying to retrieve is zero;
  \item If the index is zero, we return the value of the current memory location;
  \item Otherwise, if we have not reached the desired address yet, we perform a recursive call on the remaining memory;
\end{itemize}

Finally, the function for writing a value to a memory location is defined as:

\begin{lstlisting}[style=Rocq]
Definition set_cell (m : vm) (i : nat) (c : cell) : vm :=
  let fix set_cell_aux (cells : list cell) (i : nat) (c : cell) : list cell :=
    match cells, i with
    | nil, O => c :: nil
    | nil, S i' => Z0 :: (set_cell_aux nil i' c)
    | _ :: xs, O => c :: xs
    | x :: xs, S i' => x :: (set_cell_aux xs i' c)
    end
  in
  match m with
  | Vm regs cells => Vm regs (set_cell_aux cells i c)
  end.
\end{lstlisting}

The recursive function handles four cases:
\begin{itemize}
  \item If the memory is empty, but we reached the intended address, we expand the memory with one last cell where we store the content;
  \item If the memory is empty, and we have not reached the desired address yet, we create an empty cell and make a recursive call;
  \item If we reached the intended address, we overwrite the current content with the new content;
  \item Finally, if we have not reached the intended address yet, we perform a recursive call on the remaining memory;
\end{itemize}

The only remaining task is to define a function that simulates program execution, ideally we would want that function to have type \texttt{vm $\to$ program $\to$ vm} taking the initial state of the virtual machine and the program as inputs and returning the new state of the virtual machine.
Unfortunately, as we mentioned in \Cref{subsec:funterm}, Rocq does not allow for the definition of functions of which we cannot prove termination, and proving it for this function would entail solving the halting problem. We thus resort to using fuel based recursion for this case.

\begin{lstlisting}[style=Rocq]
Fixpoint run (m : vm) (p : program) (fuel : nat) : vm :=
  match p, fuel with
  | _, O => m
  | Block _ _ is j, S fuel' =>
    let m := run_insts m is in
    match j with
    | CondJump c r v b1 b2 =>
      if eval_cond m c r v then
        run (run_phis m p b1) b1 fuel'
      else
        run (run_phis m p b2) b2 fuel'
    | Jump b1 => run (run_phis m p b1) b1 fuel'
    | Ret r => set_reg m 0 (get_reg m r)
    end
  end.
\end{lstlisting}

The procedure works this way: if we are out of fuel we terminate, and we return the current state of the virtual machine, otherwise we proceed with the computation.
We run the body of instructions of the current block with the function \texttt{run\_insts}, yielding a new state of the virtual machine. We then treat each jump instruction differently, in the case of a conditional jump we evaluate the condition with the \texttt{eval\_cond} function, in the other two cases no evaluation is needed. Finally, before jumping to the next block we execute its $\phi$-instructions, to do so we call the \texttt{run\_phis} function passing as arguments the virtual machine, the current block and the successor block.
We continue with the computation until we either run out of fuel or we reach the \texttt{Ret} instruction, saving the result of the program to register zero.