% Errors

\chapter{Background}
\label{cha:background}

In this chapter, we present the tools and concepts employed throughout this project. We begin by introducing the Coq Proof Assistant, highlighting the features that make it suitable for our implementation. We then describe the Single Static Assignment form, the intermediate representation family used in our compiler. Finally, we discuss the theoretical foundations of register assignment, with particular attention to SSA programs.

\section{The Coq Proof Assistant}

The core of our register assignment is implemented in \textit{Coq}, an interactive proof assistant based on a functional language called \textit{Gallina}. Other than exposing a language for performing computation Coq also provides us with tools for formal verification, such as the possibily to define and prove facts about functions and other objects.

\subsection{Function Termination}
\label{subsec:funterm}

A fundamental feature of Coq is its enforcement of termination in all function definitions. Recursive functions are typically defined using the \texttt{Fixpoint} keyword, which requires pattern matching over inductive types. Coq statically checks that, for each recursive call, there exists a structurally decreasing argument, guaranteeing termination by eventually reaching a base case.

Some recursive functions, however, do not conform to this syntactic criterion. In such cases, we are offered two common workarounds:

\begin{enumerate}
    \item \textbf{Fuel-based recursion}: this approach involves adding an artificial decreasing argument (commonly named \texttt{fuel}) to the function signature. The function then proceeds recursively while decrementing \texttt{fuel} at each step. Termination is guaranteed when \texttt{fuel} reaches zero. The drawback is that an upper bound on the number of iterations must be known in advance, which may be difficult to determine and, if underestimated, can lead to incomplete computations;
    \item \textbf{Using \texttt{Function} with a termination proof}: This alternative allows for the definition of more general recursive functions as long as we provide an explicit proof of their termination. Usually the proof of termination consists in proving the existance of a function from one of the arguments to \texttt{nat} such that the image of the function decreases after each iteration;
\end{enumerate}

In this project, for functions whose proof is non-trivial we usually resort to the fuel-based approach, with the exception of the coloring algorithm, which is at the core of our register assignment, of which we write a termination proof.

\subsection{OCaml Extraction}
% Content to be added.

\section{Single Static Assignment Form}
\label{sec:ssa}

The intermediate representation utilizes the Single Static Assignment form due to its structural properties that, among other benefits, greatly simplify register assignment. An SSA program satisfies the following constraints:

\begin{itemize}
    \item Each variable is assigned exactly once;
    \item Every use of a variable is dominated by its unique definition.
\end{itemize}

To make our SSA intermediate representation able to express most of the programs, we must introduce additional features such as the concept of a control flow.

\subsection{Control Flow Graphs}
\label{subsec:cfg}

To represent the control flow of programs, we employ Control Flow Graphs. A CFG is defined as the triple $(B, CF, \textbf{start})$, where:

\begin{itemize}
    \item $B$ is the set of \textit{basic blocks}, each consisting of a sequence of instructions preceded by a $\phi$ section and terminated by a control transfer instruction;
    \item $CF \subseteq B \times B$ is the control flow relation, indicating allowed transitions between blocks;
    \item $\textbf{start} \in B$ is the designated entry point of the program;
\end{itemize}

We will use this definition of a CFG during the implementation to define programs written in our intermediate representation.

\subsection{The $\phi$ Operator}
\label{subsec:phi}

Due to the single-assignment constraint in SSA, merging variable values from multiple control paths requires the use of $\phi$ instructions. A $\phi$ instruction has the general form:

\[
x \leftarrow \phi(y_1, y_2, , \dots, y_n)
\]

Where each argument indicates that the value of $y_i$ should be assigned to $x$ if the control comes from the $i$-th incoming control flow path. Given the previous definition it follows that $\phi$ operations are only useful if they are placed at the beginning of a basic block. An important thing to note is that semantically these instructions are executed during the jump from the predecessor block and not at the beginning of the block.

An basic example of the usage of the $\phi$ operator is shown in \Cref{fig:phi-usage}.

\begin{figure}[ht]
    \centering
    \begin{tikzpicture}[
        node distance=10mm,
        every node/.style={draw, align=left, inner sep=4pt},
        >={Stealth}
    ]
    \node (entry)   at (0, 0)       {$\dots$};
    \node (b1)      at (-1.5, -1.5) {$r_1 \leftarrow 5$};
    \node (b2)      at (1.5, -1.5)  {$r_2 \leftarrow 6$};
    \node (end)     at (0, -3)      {$r_3 \leftarrow \phi(r_1, r_2)$ \\ ret $r_3$};

    \draw[->] (entry) -- (b1);
    \draw[->] (entry) -- (b2);
    \draw[->] (b1) -- (end);
    \draw[->] (b2) -- (end);
    \end{tikzpicture}
    \caption{An example of the usage of a $\phi$ operator}
    \label{fig:phi-usage}
\end{figure}

We may also find multiple $\phi$ instructions grouped together at the beginning of a block, in that case we have to remember an important property, which is the fact that all the assignments performed by the $\phi$s are executed in parallel. This aspect must be carefully preserved during SSA destruction, as the order of the assignments may influence the resulting program by causing overwrites.

\section{Register Assignment}
\label{sec:ra}

Register assignment is the process of assigning a potentially unbounded number of program variables to a limited number of physical registers. A well-known approach reduces this problem to graph coloring.

Given a program, we construct its interference graph $G = (V, E)$ where:

\begin{itemize}
    \item $V$ is the set of variables;
    \item while $E$ is the set of edges such that $\{ u, v \} \in E$ iff the variables $u$ and $v$ are simultaneously live at some program point, and therefore cannot share the same register.
\end{itemize}

A valid $k$-coloring of the interference graph, where each color represents a physical register, corresponds to a feasible register assignment for a machine with $k$ registers.

\subsection{Register Assignment in SSA Form}
\label{subsec:ssara}

While graph coloring is $\mathcal{NP}$-complete for arbitrary graphs, the interference graphs of programs in SSA form have a special structure: they are \textit{chordal} graphs. A chordal graph is one in which every cycle of four or more vertices has a chord, i.e., an edge connecting two non-consecutive vertices.

This structural property allows optimal register assignment to be performed in polynomial time making SSA form not only more analyzable but also more efficient for code generation tasks such as register assignment.