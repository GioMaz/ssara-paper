% Errors

\chapter{Implementation}
\label{cha:implementation}

In this chapter, we provide an overview of the design and implementation choices that guided the development of our register allocator. The implementation is structured in a modular way, beginning with the definition of the syntax and semantics of an intermediate language in Static Single Assignment (SSA) form. We then detail the steps required to perform register allocation, namely liveness analysis, graph coloring, and SSA destruction.

\section{Syntax}
\label{sec:syntax}

The primary goal in defining the syntax of our intermediate language is to leverage Coq’s type system to rule out as many ill-formed SSA programs as possible, as discussed in \Cref{sec:ssa}. We begin by describing how registers are represented in our language.

\subsection{Registers}

Our implementation uses two kinds of registers: virtual registers in the earlier phases of register allocation, and physical registers in the final phase. To support both use cases, we define the syntax of our intermediate language generically over the type of registers.

Coq’s type classes provide a convenient mechanism to abstract over this register type. We define a type class RegClass that specifies a type of registers, a boolean equality function, and a proof of decidable equality:

\begin{lstlisting}[language=Coq]
Class RegClass := {
reg : Set;
reg_eqb : reg -> reg -> bool;
reg_eq_dec : forall r r' : reg, {r = r'} + {r <> r'};
}.
\end{lstlisting}

Each instantiation of this class corresponds to a concrete register representation. For virtual registers, we use the set of natural numbers, which, although bounded by Coq's runtime limits, can be treated as unbounded for our purposes. For physical registers, we define a finite set that corresponds to the 64-bit general-purpose registers of the x86 architecture.

Throughout the implementation, every register is understood to be either virtual or physical depending on the phase of the compilation pipeline.

\subsection{Arithmetic/Logic Instructions}

The representation supports a small set of values and expressions. A value can be either an immediate integer, a register, or a pointer to a memory location (represented by a natural number):

\begin{lstlisting}[language=Coq]
Definition ptr : Type := nat.

Inductive val : Type :=
| Imm (x : Z)
| Reg (r : reg)
| Ptr (p : ptr)
.
\end{lstlisting}

We then define the type of expressions. These include simple values, memory loads, and arithmetic or logical operations. The syntax is intentionally simple, and expressions are restricted to avoid unnecessary complexity in later stages such as register allocation:

\begin{lstlisting}[language=Coq]
Inductive expr : Type :=
| Val : val -> expr
| Load : val -> expr
| Add : reg -> val -> expr
| Sub : reg -> val -> expr
...
.
\end{lstlisting}

Binary expressions always use a register as the first operand, preventing expressions that involve only constants, since in that case the result could be computed during a previous step of constant folding. Another thing to note is that, for the sake of register allocation, a differentiation between unary, binary and n-ary expressions is useless as we are only concerned with the operators of an expression (the registers) and not the operation.

The instruction type reflects the core operations in our language. Instructions either define a register by assigning it the result of an expression, or store a value into memory:

\begin{lstlisting}[language=Coq]
Inductive inst : Type :=
| Def (r : reg) (e : expr)
| Store (v : val) (r : reg)
.
\end{lstlisting}

The Store instruction is treated specially because it does not produce a result that can be assigned to a register. For this reason, it cannot be expressed as a Def.

\subsection{Phi Instructions}

As discussed in \Cref{sec:ssa}, phi nodes allow the assignment of values based on control-flow predecessors. We define them as follows:

\begin{lstlisting}[language=Coq]
Definition phi_arg : Type := (reg * lbl).

Inductive phi : Type :=
| Phi (r : reg) (rs: list phi_arg)
.
\end{lstlisting}

% Here, each phi_arg pairs a register with a label identifying the originating block. Initially, we experimented with a label-free control flow representation that used direct pointers to blocks. However, as we will explain later, this made the semantics unnecessarily difficult to define, leading us to prefer label-based control flow.

\subsection{Blocks and Jump Instructions}

Normal and phi instructions are defined separately so that we can enforce a block structure where phi instructions must appear first, followed by normal instructions. A block also has an entry label and ends with a jump instruction that defines the control flow:

\begin{lstlisting}[language=Coq]
CoInductive block : Type :=
| Block (l : lbl) (ps : list phi) (is : list inst) (j : jinst)

with jinst : Type :=
| CondJump : cond -> reg -> val -> block -> block -> jinst
| Jump : block -> jinst
| Halt : jinst
.
\end{lstlisting}

Control flow is encoded directly using block references instead of labels, preventing accidental jumps to nonexistent blocks. This definition naturally forms a control-flow graph (CFG), where blocks are nodes and jump instructions define the edges.

Finally since a CFG as we described in \Cref{subsec:cfg} is a set of blocks where we identify a start block and a control flow relation, it is sufficient to provide this definition:

\begin{lstlisting}[language=Coq]
Definition program : Type := block.
\end{lstlisting} as the starting point of the CFG is the first block we encounter during a visit, and the set of blocks of the program is the set of blocks reachable from the first block.


\subsection{Limitations}

Despite our efforts to use Coq's type system to rule out incorrect programs, certain ill-formed programs cannot be excluded purely by the syntax. We provide examples of such cases using custom notations for readability.

For instance, multiple assignments to the same register or the use of undefined registers are still possible:

\begin{lstlisting}[language=Coq]
Definition double_assignment : block :=
Block 0 [] [
r(1) <- (Imm 0);
r(1) <- (Imm 1)
]
Halt
.

Definition undefined_variable : block :=
Block 0 [] [r(1) <- (Reg 0)] Halt
.
\end{lstlisting}

Similarly, labels are not globally unique, which can lead to conflicting block labels:

\begin{lstlisting}[language=Coq]
Definition double_lbl_2 : block := Block 0 [] [] Halt.
Definition double_lbl_1 : block := Block 0 [] [] (Jump double_lbl_2).
\end{lstlisting}

Finally, phi instructions may include inconsistent or invalid arguments. For example, the number or identity of predecessors listed in a phi instruction may not match the actual control-flow structure:

\begin{lstlisting}[language=Coq]
Definition ill_formed_phi_2 : block :=
Block 1 [r(0) <- phi [(1, 0); (2, 1); (3, 2)]] [] Halt
.
Definition ill_formed_phi_1 : block :=
Block 0 [] [] (Jump ill_formed_phi_2)
.
\end{lstlisting}

Although these issues cannot be resolved by the type system alone, they are caught during further semantic analysis or preprocessing phases.

\section{Semantics}

To reason formally about program behavior, we implement a small-step interpreter that defines the operational semantics of our intermediate language. This interpreter is used both to validate the behavior of the language and to support later verification efforts.

\section{Liveness Analysis}

In this phase, we compute the set of live variables at each program point. This information is essential for determining which variables interfere and, therefore, cannot be assigned to the same register.

\section{Coloring}

Based on the liveness information, we construct an interference graph and apply a graph coloring algorithm to assign physical registers. We ensure the algorithm terminates and produces a valid coloring, providing a proof in Coq.

\section{SSA Destruction}

The final phase rewrites the program to remove SSA-specific constructs such as phi nodes. This involves inserting move instructions and reordering instructions where necessary to preserve correctness while transitioning to a non-SSA representation.