% Errors

\chapter{Background}
\label{cha:background}

In this chapter, we present the tools and concepts employed throughout this project. We begin by introducing the Coq Proof Assistant, highlighting the features that make it suitable for our implementation. We then describe the Single Static Assignment form, the intermediate representation family used in our compiler. Finally, we discuss the theoretical foundations of register assignment, with particular attention to SSA programs.

\section{The Coq Proof Assistant}

The core of our register assignment is implemented in \textit{Coq}, an interactive proof assistant based on a functional language called \textit{Gallina}. Other than exposing a language for performing computation Coq also provides us with tools for formal verification, such as the possibily to define and prove facts about functions and other objects.

\subsection{Function Termination}
\label{subsec:funterm}

A fundamental feature of Coq is its enforcement of termination in all function definitions. Recursive functions are typically defined using the \texttt{Fixpoint} keyword, which requires pattern matching over inductive types. Coq statically checks that, for each recursive call, there exists a structurally decreasing argument, guaranteeing termination by eventually reaching a base case.

Some recursive functions, however, do not conform to this syntactic criterion. In such cases, we are offered two common workarounds:

\begin{enumerate}
    \item \textbf{Fuel-based recursion}: this approach involves adding an artificial decreasing argument (commonly named \texttt{fuel}) to the function signature. The function then proceeds recursively while decrementing \texttt{fuel} at each step. Termination is guaranteed when \texttt{fuel} reaches zero. The drawback is that an upper bound on the number of iterations must be known in advance, which may be difficult to determine and, if underestimated, can lead to incomplete computations;
    \item \textbf{Using \texttt{Function} with a termination proof}: This alternative allows for the definition of more general recursive functions as long as we provide an explicit proof of their termination. Usually the proof of termination consists in proving the existance of a function from one of the arguments to \texttt{nat} such that the image of the function decreases after each iteration;
\end{enumerate}

In this project, for functions whose proof is non-trivial we usually resort to the fuel-based approach, with the exception of the coloring algorithm, which is at the core of our register assignment, of which we write a termination proof.

\subsection{OCaml Extraction}
% Content to be added.

\section{Single Static Assignment Form}
\label{sec:ssa}

The intermediate representation utilizes the Single Static Assignment form due to its structural properties that, among other benefits, greatly simplify register assignment. An SSA program satisfies the following constraints:

\begin{itemize}
    \item Each variable is assigned exactly once;
    \item Every use of a variable is dominated by its unique definition.
\end{itemize}

\subsection{Control Flow Graphs}
\label{subsec:cfg}

To represent the control flow of programs, we employ Control Flow Graphs. A CFG is defined as the triple $(B, CF, \textbf{start})$, where:

\begin{itemize}
    \item $B$ is the set of \textit{basic blocks}, each consisting of a sequence of instructions preceded by a $\phi$ section and terminated by a control transfer instruction;
    \item $CF \subseteq B \times B$ is the control flow relation, indicating allowed transitions between blocks;
    \item $\textbf{start} \in B$ is the designated entry point of the program;
\end{itemize}

We will use this definition of a CFG during the implementation to define programs written in our intermediate representation.

\subsection{The $\phi$ Operator}
\label{subsec:phi}

Due to the single-assignment constraint in SSA, merging variable values from multiple control paths requires the use of $\phi$ instructions. A $\phi$ instruction has the general form:

\[
x \leftarrow \phi(y_1, y_2, , \dots, y_n)
\]

Where each argument indicates that the value of $y_i$ should be assigned to $x$ if the control comes from the $i$-th incoming control flow path. Given the previous definition it follows that $\phi$ operations are only useful if they are placed at the beginning of a basic block. An important thing to note is that semantically these instructions are executed during the jump from the predecessor block and not at the beginning of the block.

An basic example of the usage of the $\phi$ operator is shown in \Cref{fig:phi-usage}.

\begin{figure}[ht]
    \centering
    \begin{tikzpicture}[
        node distance=10mm,
        every node/.style={draw, align=left, inner sep=4pt},
        >={Stealth}
    ]
    \node (entry)   at (0, 0)       {$\dots$};
    \node (b1)      at (-1.5, -1.5) {$r_1 \leftarrow 5$};
    \node (b2)      at (1.5, -1.5)  {$r_2 \leftarrow 6$};
    \node (end)     at (0, -3)      {$r_3 \leftarrow \phi(r_1, r_2)$ \\ ret $r_3$};

    \draw[->] (entry) -- (b1);
    \draw[->] (entry) -- (b2);
    \draw[->] (b1) -- (end);
    \draw[->] (b2) -- (end);
    \end{tikzpicture}
    \caption{Example usage of the $\phi$ operator}
    \label{fig:phi-usage}
\end{figure}

We may also find multiple $\phi$ instructions grouped together at the beginning of a block, in that case we have to remember an important property, which is the fact that all the assignments performed by the $\phi$s are executed in parallel. This aspect must be carefully preserved during SSA destruction, as the order of the assignments may influence the resulting program by causing overwrites.

\section{Register Assignment}
\label{sec:ra}

Register assignment is the process of assigning a potentially unbounded number of program variables to a limited number of physical registers. A well-known approach reduces this problem to graph coloring of the interference graph.

\begin{definition}[Interference Graph]\label{def:ig}
    Given a program, a graph $G = (V, E)$ where $V$ is the set of variables of the program and $\{ u, v \} \in E$, iff variables $u$ and $v$ are live at the same time for at least one instruction of the program.
\end{definition}

It is immediate to see that a $k$-coloring of the interference graph, where each color represents a physical register, corresponds to a feasible register assignment for a machine with $k$ registers.

\subsection{Register Assignment in SSA Form}
\label{subsec:ssara}

Before talking about register assignment in SSA form we need to define some properties of nodes and graphs.

\begin{definition}[Simplicial node]\label{def:simplicial}
    Given a graph $G = (V, E)$, a node $u \in E$ is simplicial, iff the neighborhood of $u$ is a clique.
\end{definition}

\begin{definition}[Chordal graph]\label{def:chordal}
    A graph for which there exists a perfect elimination ordering, that is, there exists a simplicial node such that, if we remove that node the graph is still chordal.
\end{definition}

Another way we can express \Cref{def:chordal} is the following, it will become especially useful during the verification phase of our project.

\[
\inferrule*[right=ChordalEmpty]{
}{
    \text{chordal} \; \varnothing
}
\]

\[
\inferrule*[right=ChordalStep]{
    \exists u \; \text{simplicial} \; G \; u \\
    \text{chordal} \; (G \setminus \{ u \})
}{
    \text{chordal } G
}
\]

The reason why chordal graphs are particularly appealing is that, while graph coloring for normal graphs is an NP-complete problem, there exist coloring algorithms for this particular subset of graphs that run in polynomial time.

\begin{theorem}[Chordality]
    The interference graph of a program in SSA form is chordal~\cite{...}.
\end{theorem}

% TODO: mention the author of proof at https://compilers.cs.uni-saarland.de/papers/ifg_ssa.pdf

While register assignment is NP-complete for an arbitrary representation, registers in SSA form representations are assignable in polynomial time.