% Errors

\chapter{\gls{jair}}
\label{cha:jair}

Here, we detail the implementation of \gls{jair}. In particular, in \Cref{sec:jair-syntax}, we define the syntax of the language in \gls{bnf}, and we show its implementation in Rocq. In \Cref{sec:jair-vm}, we define its semantics as a virtual machine.

\section{The \gls{jair} Syntax}
\label{sec:jair-syntax}

\gls{jair} leverages the type system of Rocq to rule out as many ill-formed \gls{ssa} programs as possible. We begin by describing how registers and labels are represented in our language. We then proceed in defining the different types of instructions, namely ALU-instructions, $\phi$-instructions, and jump instructions. Then, we define the basic block type.
At the end of the section we discuss the limitations of \gls{jair} by showing some examples.

\subsection{Registers}

Our implementation uses two kinds of registers: virtual registers in the earlier phases of \gls{ra}, and physical registers in the final phase. To support both virtual and physical registers, we make \gls{jair} parametric over the type of registers. To this end, we define the \texttt{IR} module. The \texttt{IR} module has the following signature.

\begin{lstlisting}[style=Rocq]
Module MakeIR (IR: IR_PARAMS).
  (* ... *)
\end{lstlisting}

Where \texttt{IR\_PARAMS} are the following parameters:
\begin{itemize}
    \item The register type \texttt{reg}, the set of all the registers we can choose from;
    \item A proof for the decidability of the logical equality for the register type, namely \texttt{reg\_eq\_dec};
\end{itemize}

Virtual registers use the set of natural numbers.

\begin{lstlisting}[style=Rocq]
Definition vreg := nat.
\end{lstlisting}

Physical registers, correspond to the 64-bit general-purpose registers of the x86-64 architecture.

\begin{lstlisting}[style=Rocq]
Inductive preg : Type :=
  | RAX
  | RBX
  | RCX
  (* ... *)
  | UNASSIGNED.
\end{lstlisting}

We also include the \texttt{UNASSIGNED} register, this register is used as a default value for the coloring, removing the need of returning an optional value everywhere. Later we will prove that the coloring function will never return this constructor.

\subsection{Labels}

We now define the non-terminal of a block label:

\begin{grammar}
<label> ::= `Normal' <natural> | `Point1' <natural> | `Point2' <natural>
\end{grammar}

Implemented in Rocq with the following definition:

\begin{lstlisting}[style=Rocq]
Inductive lbl : Type :=
  | Normal : nat -> lbl
  | Point1 : nat -> lbl
  | Point2 : nat -> lbl.
\end{lstlisting}

The label type has three constructors, \Cref{sec:destruct} discusses this more in depth. With the constructors \texttt{Point1} and \texttt{Point2} we identify additional basic blocks introduced in later stages of the pipeline, whereas with the \texttt{Normal} constructor we identify the blocks that already existed before \gls{ra}.

\subsection{ALU-Instructions}

In order to perform computations, \gls{jair} provides arithmetic and logical instructions.
We define the \texttt{val} type which represents an operand of these instructions. It can be either an immediate integer, a register, or a pointer to a memory location (represented by a natural number). The following is the \gls{bnf} definition of the value type, along with its type definition.

\begin{grammar}
<value> ::= `i(' <integer> `)' | `r(' <register> `)' | `p(' <pointer> `)'
\end{grammar}

\begin{lstlisting}[style=Rocq]
Inductive val : Type :=
  | Imm (x : Z)
  | Reg (r : reg)
  | Ptr (p : nat).
\end{lstlisting}

We define the syntax of expressions.

\begin{minipage}{0.45\textwidth}
\begin{grammar}
<expression> ::= <value>
\alt `load' <value>
\alt `r(' <register> `)' `+' <value>
\alt `r(' <register> `)' `-' <value>
\alt `r(' <register> `)' `*' <value>
\alt `r(' <register> `)' `/' <value>
\end{grammar}
\end{minipage}
\hfill
\begin{minipage}{0.45\textwidth}
\begin{lstlisting}[style=Rocq]
Inductive expr : Type :=
  | Val : val -> expr
  | Load : val -> expr
  | Add : reg -> val -> expr
  | Sub : reg -> val -> expr
  | Mul : reg -> val -> expr
  | Div : reg -> val -> expr.
\end{lstlisting}
\end{minipage}

These include registers, memory loads, and arithmetic and logical operations. The expression non-terminal is not defined recursively to preserve the linearity of the data structure.

As can be seen from the previous definitions, binary expressions always use a register as the first operand. This prevents expressions where all the operands are constants. In that case, in fact, the result could be computed during a previous step of constant folding. It should be also mentioned that, for the sake of \gls{ra}, a differentiation between unary, binary and $n$-ary expressions is unnecessary. This is because we are only concerned with the identities of the operands of an expression (the registers) and not the operators.

The instruction type \texttt{inst} reflects the core operations in our language. An instruction can either define a register by assigning to it the result of an expression, or it can store a value into memory.

\begin{grammar}
<instruction> ::= `r(' <register> `)' `<-' <expression>
\alt `store' `r(' <register> `)' `r(' <register> `)'
\end{grammar}

\begin{lstlisting}[style=Rocq]
Inductive inst : Type :=
  | Def (r : reg) (e : expr)
  | Store (v : val) (r : reg).
\end{lstlisting}

\texttt{Store} is treated specially, because it does not produce a result that can be assigned to a register. Therefore, it cannot be expressed as a \texttt{Def}.
Instructions are often grouped into sequences that are executed linearly. To represent it, we introduce the following non-terminals in our grammar.

\begin{grammar}
<instructions> ::= <instruction> `;' <instructions> | <instruction>

<instructions-or-empty> ::= `[' <instructions> `]' | `[]'
\end{grammar}

\subsection{$\phi$-Instructions}

\Cref{sec:ssa} defines a sequence of $\phi$-instructions as a parallel move based on the predecessor in the control flow.
We try to encode the data required by a $\phi$-instruction with the following definitions. We define the syntax of the arguments of a $\phi$-instruction.

\begin{grammar}
<phi-arguments> ::= `(' <register> `,' <label> `)' `;' <phi-arguments> | (<register>, <label>)

<phi-arguments-or-empty> ::= `[' <phi-arguments> `]' | `[]'
\end{grammar}

And its correspondent type, for a single argument:

\begin{lstlisting}[style=Rocq]
Definition phi_arg : Type := (reg * lbl).
\end{lstlisting}

Semantically, the \texttt{reg} instance is the source of the copy iff the control flow comes from the \texttt{lbl} instance.

We define the syntax of the $\phi$-instruction, as an assignment of one of the possible \synt{phi-arguments} to the destination \synt{register}.

\begin{grammar}
<phi> ::= `r(' <register> `)' `<-' `phi' <phi-arguments-or-empty>
\end{grammar}

\begin{lstlisting}[style=Rocq]
Inductive phi : Type :=
| Phi : reg -> list phi_arg -> phi.
\end{lstlisting}

Much like ALU-instructions, $\phi$-instructions are often grouped into sequences. Because of that we introduce the following non-terminals.

\begin{grammar}
<phis> ::= <phi> `;' <phis>

<phis-or-empty> ::= `[' <phis> `]' | `[]'
\end{grammar}

% Here, each \texttt{phi\_arg} pairs a register with a label identifying the originating block. Initially, we experimented with a label-free control flow representation that used direct pointers to blocks. However, as we will explain later, this made the semantics unnecessarily difficult to define, leading us to prefer label-based control flow.

\subsection{Blocks and Jump Instructions}

ALU-instructions and $\phi$-instructions are defined separately. This enforces the fact that, in well-formed basic blocks, the $\phi$-instructions appear first, followed by ALU-instructions, and, finally, by a jump instruction.
Before defining the syntax of a jump instruction, we introduce the conditional operators.

\begin{minipage}{0.45\linewidth}
\begin{grammar}
<condition> ::= `CondEq'
\alt `CondNe'
\alt `CondLt'
\alt `CondLe'
\alt `CondGt'
\alt `CondGe'
\end{grammar}
\end{minipage}
\hfill
\begin{minipage}{0.45\linewidth}
\begin{lstlisting}[style=Rocq]
Inductive cond : Type :=
  | CondEq
  | CondNe
  | CondLt
  | CondLe
  | CondGt
  | CondGe.
\end{lstlisting}
\end{minipage}

These operators represent the possible ways of comparing two items, we use them in the definition of the jump instruction.

\begin{grammar}
<jump-instruction> ::= `if' <condition> <register> <value> `then' <block> `else' <block>
\alt `jump' <block>
\alt `ret' `r(' <register> `)'
\end{grammar}

This definition uses the \synt{block} non-terminal, representing a basic block. We define its syntax here:

\begin{grammar}
<block> ::= `Block' `(' <lbl> `)' <phis-or-empty> <instructions-or-empty> `(' <jump-instruction> `)'
\end{grammar}

We then implement the jump instruction type in mutual recursion with the block type.

\begin{lstlisting}[style=Rocq]
CoInductive block : Type :=
  | Block (l : lbl) (ps : list phi) (is : list inst) (j : jinst)
with jinst : Type :=
  | CondJump : cond -> reg -> val -> block -> block -> jinst
  | Jump : block -> jinst
  | Ret : reg -> jinst.
\end{lstlisting}

Control flow is encoded directly using block references instead of labels, preventing accidental jumps to nonexistent blocks. This definition naturally forms a \gls{cfg}, where the nodes are the basic blocks and jump instructions define the control flow relation. Finally, in order to define the starting point of the \gls{cfg}, we provide this definition.

\begin{lstlisting}[style=Rocq]
Definition program : Type := block.
\end{lstlisting}

Where the starting point is the first block we encounter during a visit of \texttt{program}, and the set of blocks of the \gls{cfg} is the set of blocks reachable from the starting point.

After covering the \gls{jair} implementation, we demonstrate its capabilities in \Cref{fig:example-jair} with an example of the Fibonacci function along with the same example in a \gls{ssa} form representation.

\begin{figure}[ht]
\centering
\begin{minipage}{0.65\textwidth}
\begin{lstlisting}[style=Rocq]
Definition b3 : block :=
  Block (Normal 3) [] [] (ret r(6)).

CoFixpoint b2 : block :=
  Block (Normal 2) [
    r(3) <- phi [(0, Normal 1); (4, Normal 2)];
    r(4) <- phi [(1, Normal 1); (6, Normal 2)];
    r(5) <- phi [(2, Normal 1); (7, Normal 2)]
  ] [
    r(6) <- r(4) + r(3);
    r(7) <- r(5) - i(1)
  ] (
    if r(7) = i(1)
    then b3
    else b2
  ).

Definition b1 : block :=
  Block (Normal 1) [] [
    r(0) <- i(0);  (* Second temp *)
    r(1) <- i(1);  (* First temp *)
    r(2) <- i(12)  (* Iterator *)
  ] (
    jump b2
  ).
\end{lstlisting}
\end{minipage}
\hfill
\begin{minipage}{0.30\textwidth}
\centering
\begin{tikzpicture}[
    node distance=10mm,
    every node/.style={draw, align=left, inner sep=4pt},
    >={Stealth}
]
  \node (entry)   at (0, 0)   {$r_0 \leftarrow 0$ \\ $r_1 \leftarrow 1$ \\ $r_2 \leftarrow 12$};
  \node (loop)    at (0, -3)  {$r_3 \leftarrow \phi(r_0, r_4)$ \\ $r_4 \leftarrow \phi(r_1, r_6)$ \\ $r_5 \leftarrow \phi(r_2, r_7)$ \\ $r_6 \leftarrow r_4 + r_3$ \\ $r_7 \leftarrow r_5 - 1$};
  \node (end)     at (0, -5.5)  {ret $r_6$};
  \draw[->] (entry) -- (loop);
  \draw[->] ([xshift=10pt]loop.south) to[out=315, in=45, looseness=4] ([xshift=10pt]loop.north);
  \draw[->] (loop) -- (end);
\end{tikzpicture}
\end{minipage}
\caption{Code for the Fibonacci function in \gls{jair} along with the same code in a \gls{ssa} form representation}
\label{fig:example-jair}
\end{figure}

\subsection{Limitations}
\label{subsec:limitations}

Initially, we opted for a label-less representation of basic blocks.
Later in the project we saw the necessity of introducing them. Take the following example of a label-less program:

\begin{lstlisting}[style=Rocq]
Definition b3 : block :=
  Block [r(3) <- phi [1, 2]] [] (ret r(3)).
Definition b2 : block :=
  Block [] [r(2) <- i(2)] (Jump b3).
Definition b1 : block :=
  Block [] [r(1) <- i(1)] (Jump b2).
\end{lstlisting}

At line 2, we use a $\phi$-instruction. However, we do not encode the order of the predecessors \texttt{b1} and \texttt{b2}. Because of that, the $\phi$-instruction cannot know which of the two arguments belongs in which predecessor. In this simple case, it is immediate to see that \texttt{r1} belongs to \texttt{b1}, and \texttt{r2} belongs to \texttt{b2}. Even so, we must keep in mind that some $\phi$-instructions may use variables that are not defined in their direct predecessors. For this reason, we adopted labels at the cost of introducing possible inconsistencies in the representation. We will now talk about these inconsistencies.

First, uniqueness of labels is not enforced. This can lead to conflicting block labels, as shown in the following example, where we define two blocks with label \texttt{(Normal 0)}.

\begin{lstlisting}[style=Rocq]
CoFixpoint b1 : block :=
  Block (Normal 0) [] [] (jump b2)
with b2 : block :=
  Block (Normal 0) [] [] (jump b1).
\end{lstlisting}

Another problem is that $\phi$-instructions may include inconsistent or invalid arguments. In the following example, the number of predecessors, listed in the $\phi$-instruction at line 2, does not match the actual number of predecessors. Furthermore, the labels referenced by the $\phi$-instruction do not exist:

\begin{lstlisting}[style=Rocq]
Definition b2 : block :=
  Block (Normal 1) [
    r(1) <- phi [(1, 5); (2, 6); (3; 7)]] [] (ret r(0)).
Definition b1 : block :=
  Block (Normal 0) [] [] (jump b2).
\end{lstlisting}

Despite our efforts to rule out incorrect \gls{ssa} programs, certain ill-formed programs cannot be excluded purely by the syntax. We now provide examples of such cases.

A fundamental problem is that the two core policies of a \gls{ssa} form representation (see \Cref{def:ssa}) are not enforced. In particular, multiple assignments to the same register are allowed. Take the following example:

\begin{lstlisting}[style=Rocq]
Definition b1 : block :=
  Block (Normal 0) [] [
    r(1) <- i(0);
    r(1) <- i(1)
  ]
  (ret r(1)).
\end{lstlisting}

At line 4, we define variable \texttt{r(1)} for a second time.
Moreover, the usage of undefined variables is admitted:

\begin{lstlisting}[style=Rocq]
Definition b1 : block :=
  Block (Normal 0) [] [r(1) <- r(0)] (ret r(1)).
\end{lstlisting}

In the previous snippet, at line 2, we define \texttt{r(1)}, using variable \texttt{r(0)}, which is undefined.
Although these issues cannot be resolved by the type system alone, they can be caught during a previous phase of semantic analysis.

\section{A \gls{jair} Interpreter}
\label{sec:jair-vm}

We now implement a small-step interpreter for our intermediate representation. We do this for two reasons.
The first one is to clearly state the semantics of \gls{jair}. The second one has to do with the testing of our \gls{ra} pipeline. In \Cref{cha:extraction}, we compare the result of a program executed on the interpreter virtual machine with the result of the same program executed on bare hardware. If the two results match this suggests that the semantics of the program are preserved even after \gls{ra}.
The definition of the virtual machine is straightforward as its components are just the register file, implemented as a map from registers to integers, and the memory, implemented as list of integers.

\begin{lstlisting}[style=Rocq]
Inductive vm : Type :=
  | Vm : (reg -> Z) -> list Z -> vm.
\end{lstlisting}

After defining the virtual machine, we define the primitives to interact with it. We begin with operations on the register file.

The function to read a value from a register is defined as follows:

\begin{lstlisting}[style=Rocq]
Definition get_reg (m : vm) (r : reg) : cell :=
  match m with
  | Vm regs _ => regs r
  end.
\end{lstlisting}

This function takes a virtual machine state \texttt m and a register \texttt r, and returns the content of the register  by performing $\beta$-reduction on the register file map.

The corresponding function to write a value into a register is defined as:

\begin{lstlisting}[style=Rocq]
Definition set_reg (m : vm) (r : reg) (c : cell) : vm :=
  match m with
  | Vm regs cells =>
    Vm (fun r' => if r' =? r then c else regs r') cells
  end.
\end{lstlisting}

Here, we take the current register file map and we wrap it with a lambda function, if the argument of that function matches register \texttt r, we return the value \texttt c, otherwise we perform $\beta$-reduction with the previous version of the register file map.

Now, we define analogous operations for memory access. In our implementation memory does not support random access. Instead, we use a list that grows whenever a new value is stored, filling the previously uninitialized memory locations with zeroes. The function to retrieve the content of a memory location is defined as follows:

\begin{lstlisting}[style=Rocq]
Definition get_cell (m : vm) (i : nat) : cell :=
  let fix get_cell_aux (cells : list cell) (i : nat) : cell :=
    match cells, i with
    | nil, _ => Z0
    | c :: _, O => c
    | _ :: cs, S i' => get_cell_aux cs i'
    end
  in
  match m with
  | Vm _ cells => get_cell_aux cells i
  end.
\end{lstlisting}

The recursive function considers three cases:
\begin{itemize}
  \item If the memory is empty, then the value we are trying to retrieve is Zero;
  \item If the index is Zero, we return the value of the current memory location;
  \item Otherwise, if we have not reached the desired address yet, we perform a recursive call on the remaining memory;
\end{itemize}

We define the function for writing a value to a memory location:

\begin{lstlisting}[style=Rocq]
Definition set_cell (m : vm) (i : nat) (c : cell) : vm :=
  let fix set_cell_aux (cells : list cell) (i : nat) (c : cell) : list cell :=
    match cells, i with
    | nil, O => c :: nil
    | nil, S i' => Z0 :: (set_cell_aux nil i' c)
    | _ :: xs, O => c :: xs
    | x :: xs, S i' => x :: (set_cell_aux xs i' c)
    end
  in
  match m with
  | Vm regs cells => Vm regs (set_cell_aux cells i c)
  end.
\end{lstlisting}

The recursive function handles four cases:
\begin{itemize}
  \item If the memory is empty, but we reached the intended address, we expand the memory with one last cell where we store the content;
  \item If the memory is empty, and we have not reached the desired address yet, we create an empty cell and make a recursive call;
  \item If we reached the intended address, we overwrite the current content with the new content;
  \item Finally, if we have not reached the intended address yet, we perform a recursive call on the remaining memory;
\end{itemize}

The remaining task is to define a function that simulates program execution, ideally we would want that function to have type \texttt{vm $\to$ program $\to$ vm} taking the initial state of the virtual machine and the program as inputs and returning the new state of the virtual machine.
Unfortunately, as we mentioned in \Cref{subsec:funterm}, Rocq does not allow for the definition of functions of which we cannot prove termination, and proving it for this function would entail solving the halting problem. We thus resort to using fuel based recursion for this case.

\begin{lstlisting}[style=Rocq]
Fixpoint run (m : vm) (p : program) (fuel : nat) : vm :=
  match p, fuel with
  | _, O => m
  | Block _ _ is j, S fuel' =>
    let m := run_insts m is in
    match j with
    | CondJump c r v b1 b2 =>
      if eval_cond m c r v then
        run (run_phis m p b1) b1 fuel'
      else
        run (run_phis m p b2) b2 fuel'
    | Jump b1 => run (run_phis m p b1) b1 fuel'
    | Ret r => set_reg m 0 (get_reg m r)
    end
  end.
\end{lstlisting}

The procedure works this way: if we are out of fuel, we terminate, and we return the current state of the virtual machine. Otherwise, we proceed with the computation.
We run the body of instructions of the current block with the function \texttt{run\_insts}, yielding a new state of the virtual machine. We then treat each jump instruction differently. In the case of a conditional jump we evaluate the condition with the \texttt{eval\_cond} function. Instead, in the other two cases, no evaluation is needed. Finally, before jumping to the next block we execute its $\phi$-instructions. We do that by call the \texttt{run\_phis} function passing as arguments the virtual machine, the current block, and the successor block.
We continue with the computation until we either run out of fuel, or we reach the \texttt{Ret} instruction, saving the result of the program into the first register.