% Errors

\chapter{Background}
\label{cha:background}

In this chapter, we present the tools and concepts employed throughout this project. We begin by introducing the Rocq Proof Assistant, highlighting the features that make it suitable for our implementation. We then describe the \gls{ssa} form, the intermediate representation family we use. Finally, we discuss the theoretical foundations of register assignment, with particular attention to SSA programs.

\section{The Rocq Proof Assistant}

The register assignment pipeline is implemented in Rocq, an interactive proof assistant based on a functional language called Gallina. Other than exposing a language for performing computation, Rocq also provides us with tools for formal verification, such as the possibility to define and prove facts about functions and structures.

\subsection{Function Termination}
\label{subsec:funterm}

A fundamental feature of Rocq is its enforcement of termination in all function definitions. Recursive functions are typically defined using the \texttt{Fixpoint} keyword, which requires pattern matching over inductive types. Rocq statically checks that, for each recursive call, there exists a structurally decreasing argument, guaranteeing termination by eventually reaching a base case.

Some recursive functions, however, do not conform to this criterion. Take for example the following function:

\begin{lstlisting}[style=Rocq]
Fixpoint collatz (n : nat) (steps: nat) : nat :=
  match n with
  | O => steps
  | _ =>
    if Nat.even n
    then collatz (n / 2) (S steps)
    else collatz (n * 3 + 1) (S steps)
  end.
\end{lstlisting}

This function takes a natural number \texttt n and returns the number of iterations required for the Collatz step function to converge. Here, Rocq is not able to automatically prove termination.

For cases like the previous one, we are offered two common workarounds:
The first approach is fuel-based recursion, it consists in adding an artificial decreasing argument (commonly named \texttt{fuel}) to the function signature. The function then proceeds recursively while decrementing \texttt{fuel} at each step. Termination is guaranteed when \texttt{fuel} reaches zero. The drawback is that an upper bound on the number of iterations must be known in advance, which may be difficult to determine and, if underestimated, can lead to incomplete computations.
The second approach, instead, consists in using the texttt{Function} keyword with a termination proof. This alternative allows for the definition of more general recursive functions as long as we provide an explicit proof of their termination. Usually the proof of termination consists in proving the that at least one argument has a property that decreases after each iteration;

In this project, for functions whose proof is non-trivial we usually resort to the fuel-based approach, expect for the coloring algorithm, for which we provide a termination proof.

\subsection{OCaml Extraction}
\label{subsec:extract}
% Content to be added.

\section{\glsentrylong{ssa} Form}
\label{sec:ssa}

The intermediate representation utilizes \gls{ssa} form due to its structural properties that, among other benefits, greatly simplify register assignment. An SSA program satisfies the following constraints:

\begin{itemize}
    \item Each variable is assigned exactly once;
    \item Every use of a variable is dominated by its unique definition.
\end{itemize}

\subsection{Control Flow Graphs}
\label{subsec:cfg}

To represent the control flow of a program, we employ a \gls{cfg}. A \gls{cfg} is defined as the triple $(B, CF, \textbf{start})$, where:

\begin{itemize}
    \item $B$ is the set of basic blocks, each consisting of a sequence of instructions terminated by either a jump instruction or an halt instruction;
    \item $CF \subseteq B \times B$ is the control flow relation that defines the allowed transitions between blocks;
    \item $\textbf{start} \in B$ is the entry point of the program;
\end{itemize}

We will use this definition of a \gls{cfg} during the implementation to define programs written in our intermediate representation.

\subsection{$\phi$-Instructions}
\label{subsec:phi}

Due to the single assignment policy of SSA, merging variables from multiple control paths requires the use of a $\phi$-instructions. A $\phi$-instruction has the general form:

\[
x \leftarrow \phi(y_1, y_2, , \dots, y_n)
\]

Where each argument indicates that the value of $y_i$ should be assigned to $x$ if the control comes from the $i$-th incoming control flow path. Given the previous definition it follows that $\phi$-instructions must be placed at the beginning of a basic block, and are executed during the jump from the predecessor block.

An example of the usage of the $\phi$-instruction is shown in \Cref{fig:phi-usage}.

\begin{figure}[ht]
    \centering
    \begin{tikzpicture}[
        node distance=10mm,
        every node/.style={draw, align=left, inner sep=4pt},
        >={Stealth}
    ]
    \node (entry)   at (0, 0)       {$r_1 \leftarrow 5$};
    \node (b1)      at (-1.5, -1.5) {$r_2 \leftarrow r_1 + 1$};
    \node (b2)      at (1.5, -1.5)  {$r_3 \leftarrow r_1 + 2$};
    \node (end)     at (0, -3)      {$r_4 \leftarrow \phi(r_2, r_3)$ \\ ret $r_4$};

    \draw[->] (entry) -- (b1);
    \draw[->] (entry) -- (b2);
    \draw[->] (b1) -- (end);
    \draw[->] (b2) -- (end);
    \end{tikzpicture}
    \caption{Example of the usage of a $\phi$-instruction}
    \label{fig:phi-usage}
\end{figure}

We may also find multiple $\phi$-instructions grouped together at the beginning of a block, in that case we have to remember an important property, which is the fact that all the assignments are executed in parallel. This aspect must be preserved during SSA destruction, as the order of the assignments may influence the resulting program by causing overwrites.

\section{Register Assignment}
\label{sec:ra}

Register assignment is the process of assigning a potentially unbounded number of virtual register to a limited number of physical registers. A well-known approach reduces this problem to graph coloring of the interference graph.

\begin{definition}[Interference Graph]\label{def:ig}
    Given a \gls{cfg}, a graph $G = (V, E)$ where $V$ is the set of variables used by the instructions of the \gls{cfg}, and $\{ u, v \} \in E$, iff variables $u$ and $v$ are both live for at least one instruction of the \gls{cfg}.
\end{definition}

It is immediate to see that a $k$-coloring of the interference graph, where each color represents a physical register, corresponds to a feasible register assignment for a machine with $k$ registers.

\subsection{Register Assignment in SSA Form}
\label{subsec:ssara}

Before talking about register assignment in SSA form we need to define some properties of nodes and graphs.

\begin{definition}[Simplicial node]\label{def:simplicial}
    Given a graph $G = (V, E)$, a node $u \in E$ is simplicial, iff the neighborhood of $u$ is a clique.
\end{definition}

\begin{definition}[Chordal graph]\label{def:chordal}
    A graph for which there exists a \gls{peo}, that is, there exists a simplicial node such that, if we remove that node the graph is still chordal.
\end{definition}

The reason why chordal graphs are particularly appealing is the result of the two following theorems:

\begin{theorem}[Chordality]
    The interference graph of a program in SSA form is chordal~\cite{HGG:2006:RA_SSA}.
\end{theorem}

\begin{theorem}[Coloring of chordal graphs]
    The problem of graph coloring for chordal graphs can be solved optimally and in polynomial time~\cite{golumbic2004algorithmic}.
\end{theorem}

From this follows that, while register assignment is NP-complete for arbitrary representations, this problem becomes solvable optimally and in polynomial time for programs in SSA form.

Finally, some other definitions that we will use later, during the description of the algorithm.

\begin{definition}[Chromatic number]\label{def:chromatic}
    Given a graph $G = (V, E)$, its chromatic number $\omega(G)$ is the minimum number of colors that can be assigned to the nodes of $G$ such that no two adjacent nodes have the same color.
\end{definition}

\begin{theorem}[Chromatic number of chordal graphs]\label{thm:chordal-chromatic}
    Given a chordal graph $G$, its chromatic number is equal to the size of the largest clique in $G$~\cite{golumbic2004algorithmic}.
\end{theorem}